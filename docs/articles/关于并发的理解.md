---
Title: 关于并发的理解 
Tags: 编程 
PublishDate: 2018/3/4 13:41:37 
---

在在考虑并发编程中，首先要思考的是时间是什么？ 我们可以简单的将时间看作是施加在所有事件上的顺序。在纯粹的函数式编程中，不论对表达式采用何种求值顺序，应用序，正则序也好，都不会影响最终的求值结果，只是中间过程会有所差别，在这样的编程模型中，我们似乎可以忽略时间施加在事件上的顺序，因此，函数式程序可以进行自动的并行化，没有赋值和可变量，意味着引用透明，即外延相等的函数可以相互替换，如果两个函数对于所有参数产生的结果都是一样的，那么它们就是相等的，可以相互替换的（将函数的结果缓存以加快速度，正是这一思想的诠释）。

改变从赋值的引入开始，在这之前，求值使用代换模型，如同处理数学函数一样，这个模型并不能处理赋值的场景，因此需要使用更为复杂的环境模型，在这个模型下，考虑并发编程就会带来前所未有的复杂和挑战。当然，有一个概念是始终需要明晰的，那就是关于并发和并行的区别，最简单的理解，并发是同一时间应对多件事情的能力，而并行是同一时间处理多件事情的能力。对于相互较为独立的多个事件而言，我们要想在同一时间应对，那么最好的办法就并行化，将任务分发到不同的处理单元上去。并发程序不一定是并行的，也有可能是串行的模式，他强调的是如何应对多件事情，而不是处理多件事情，人在应对多件事情的最简单办法就是按照事情的轻重缓急，将其按顺序排队处理，在并发程序中，重点强调的是如何尽可能少的减少不必要的等待。

回到并发编程的问题上来，考虑银行存取款的案例，我们知道，在计算机程序中，对于一个账号的存取款通常可以划分为两个基本的操作，读和写，我们用一个变量 b 代表用户的存款余额，那么一个存款操作就可以分解为，读取变量 b 数值，计算存款后的数值 nb，将 b 的数值修改为 nb，取款也是类似操作，考虑一个事件序列，先存款记作A，然后取款记作B，然后将事件序列（A，B）分解为基本操作序列（Ar，Aw，Br，Bw），显然，如果是单进程串行的操作，那么不会有任何意料外的结果，但是，考虑到A，B两个事件并行发生的情况会怎么样呢？这意味着这个基本操作序列（Ar，Aw）、（Br，Bw）将出现交错的情况，可能会有（Ar，Br，Aw，Bw）等 5 种交错情况，每种的执行结果都不一样。如此，并发编程中的种种问题就产生了，时间施加在事情上的顺序成了不得不仔细考量的对象，这些问题的产生的前提，除了赋值，还有共享变量。

应对这些不可以预料的问题，就是如何控制产生多种操作序列的可能性，所谓的控制就是将可能性缩小的能力，如果一件事情可能产生 100 种结果，如果我们通过某种手段将可能的结果减少到了10种甚至更少，那么我就说事情被控制住了。那么在这里如何控制呢？并发不可避免，但是我们可人为的施加秩序，最简单的办法，就是将这些操作通过加锁的方式局部串行化，即一个进程拿到锁后，其他进程等锁释放后操作，而不是同时进行。采用锁的模型简单粗暴，但是却难以掌控，会有竞态，死锁等情况，他依旧要求程序员对事情的发生的顺序有一个整体的掌控。

并发编程的问题来源与赋值和共享变量引入的时间约束，在函数式编程里我们可以丢掉赋值，全部采用不可变量，如果我们无论如何都想保留赋值，那又怎么办呢？我能怎么办，我也很绝望啊，既然想要赋值，那么就只能从问题的另一根源开刀，即共享变量，于是产生了 CSP、Actor 等模型，即限制共享变量的使用范围，我们使用共享变量的时候我们实际上是在做什么呢？在通信！某种意义上，共享的变量充当了两个进程间通信的信道，万物皆通信，而对于 CSP、Actor 模型，前者关注发送信息的实体，后者关注承载信息的信道，在应用 CSP 模型的 Go 语言里，有一句话是这么说的，“不要共享数据来通信,使用通信来共享数据。”。然并卵，这些并行计算模型很美好，但是现代计算机的冯诺曼依架构就是通过总线共享内存的。

引用 SICP 中的话
> 这里的基本现象是不同进程之间的同步，建立起共享状态，或迫使进程之间通信所产生的事件按照某种特定的顺序运行。从本质上看，在并发控制中，任何时间概念都必然与通信有着内在的密切联系。有意思的是，时间与通信之间的这种联系也出现在相对论里，在那里光是是时间和空间有关的基本常量。在处理时间和状态时，我们在计算模型领域所遭受的复杂性，事实上，可能就是物理事件中最基本的复杂性的一种反映。

更多关于并发的书可以参考《七周七并发模型》。

    