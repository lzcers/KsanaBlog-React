---
Title: 从浏览器工作机制看性能优化
PublishDate: 2018](\articles\imgs\7](\articles\imgs\9 15:31
Tags: 前端
---

## 背景

之前学习前端过程中做了不少关于性能优化的笔记，但是大多都太零散，无法串联起来，便想写一篇文章将所有知识点串起来，从浏览器的关键渲染路径来看性能优化是非常适合的，当然，前端的性能优化也不仅仅是这些，还有一些后端的优化工作也是非常有效的，决定页面用户体验不仅仅是前端，还有后端的协同工作。

## 浏览器渲染过程

### URL 解析

1. 用户输入 URL

2. 从URL 中解析出主机名

3. DNS 查询解析出主机名对应的服务器 IP

   先查本地 DNS 缓存记录 （比如 hosts 文件），没有再向 DNS 服务器查询，并将结果缓存

4. 根据 URL 提供的端口号（默认 80）请求服务器获取静态资源

   经过三次握手建立 TCP 连接，然后开始传输 HTTP 报文 （Request，Response），HTTP 协议是应用层协议，建立在 TCP](\articles\imgs\IP 协议上。

5. 关闭连接，浏览器开始解析文档

6. 如果文档中涉及其他资源则重复以上动作，直至所有资源加载完毕

### 页面渲染

![](\articles\imgs\imgs\browserRender.webp)

1. 处理 HTML 标记并构建 DOM 树。

   深度优先遍历过程，默认遇到 script 回解析执行其中的脚本，并堵塞渲染。（加上 defer,  async 属性可以控制执行 javaScript 的执行时间）

2. 处理 CSS 标记并构建 CSSOM 树。

3. 将 DOM 与 CSSOM 合并成一颗渲染树（Render Tree）。

   渲染树并不意味着就是 DOM 树，比如 Head，Display: none 等元素就不用放在这个里面。

4. 根据渲染树来布局，以计算每个节点的几何信息。（Layout、Flow）

5. 将各个节点绘制到屏幕上。（paint）
   postion 属性设为 absolute 或 fixed 等使得元素脱离文档流，它的变化不会影响其他元素，这样就可以避免重排，从而减少重绘（Repaint）。

## 从浏览器渲染机制来看性能优化

**从 HTTP 请求发起到结束，中间过程经历了文档解析与脚本执行，这个过程是时间消耗的主要原因，因而前端的性能优化就在于减少 HTTP 的往返次数以及文档解析与脚本执行的时间。**

###  解析与堵塞

我们知道 HTML 解析过程中遇到 `<script>` 标签时，浏览器会立即加载并解析执行其中的代码，导致堵塞渲染，因而将 Script 标签放在末尾是常见的一种优化技巧，在比较新的浏览器上我们也可以为 script 标签加上 defer 和 async 属性，从而控制 JavaScript 的执行实行。

![wfL82.png](..\imgs\scriptload.webp) 

```html
<script src="main.js"><](\articles\imgs\script>
```

浏览器在解析到该标签时会立即加载并执行其中的脚本，在执行 JS 过程中会堵塞接下来的解析过程，因而 `<Script>`若是放在文档头部，如果 JS 的执行时间过长就会出现的白屏现象。事实上，为了更好的用户体验，现代浏览器通常不会等到渲染树出现了才开渲染，部分内容也会被解析显示，浏览器能够渲染不完整的 DOM树和 CSSOM ，进而缩短首屏（First Paint）的白屏时间。

```html
<script src="m2.js" defer><](\articles\imgs\script>
```

通过 `defer` 属性可以将将本的执行时间推迟到所有元素解析完成后，`DOMContentLoaded`  事件触发之前。

```html
<script src="m3.js" async><](\articles\imgs\script>
```

加载完后就立即执行，适用于那些无依赖的脚本。

***DNS 预解析***
```html
<link rel="dns-prefetch" href="](\articles\imgs\](\articles\imgs\xxx.com">
```
DNS 的解析也是消耗时间的，因而在涉及多个域名的情况下，可以使用 DNS 预解析。


### 资源的加载

浏览器对资源的加载是并行的，但是不同浏览器对于同一域名的并发数量是有限的，我们看到很多大站会将静态资源下放到不同的子域名或是 CDN 上去，这样做的好处是

* 突破浏览器的并发限制
* CDN 能自动选择优质节点加快传输速度，减少源站的压力
* Cookie 静态资源请求不带 Cookie 减少传输压力

在 HTTP2 启用情况下，利用其多路复用的特性我们可以不用这么麻烦。除了这些举措，通常的优化策略**减少请求数量**，**减少请求的体积**，都是在浏览器的资源加载上发力。

* 减少请求数量： 打包CSS，JS，图片，启用 HTTP 缓存策略，使用 CDN
* 减少请求体积： 压缩CSS，JS，使用恰当的图片格式（webp）或转 base64，开 gzip

浏览器的缓存策略分为强缓存和协商缓存两类，通常我们会使用一些 HTTP 头，如 expires、cache-control、last-modified、etag 等。

除此之外我们还可以使用 属性 **Preload**、**Prefetch**，在浏览器的主渲染机制介入前就进行预加载，这使得资源可以更早加载和可用，且不堵塞页面的初步渲染。 

```html
<link rel="preload" href="](\articles\imgs\main.js" as="script">
](\articles\imgs\](\articles\imgs\ 提前加载好脚本但不执行，遇到 main.js 时直接执行。
<link rel="prefetch" href="big.jpeg">
](\articles\imgs\](\articles\imgs\ 浏览器会在空闲时下载文件并缓存，使用时直接从缓存取，
<link rel="preconnect" href="](\articles\imgs\](\articles\imgs\example.com">
<link rel="preconnect" href="](\articles\imgs\](\articles\imgs\cdn.example.com" crossorigin>
](\articles\imgs\](\articles\imgs\ 预链接，包含DNS查找、TCP连接、以及可选的TLS协议，减少潜在的连接开销。
```

使用 preload 我们可以提前处理未来的加载需求，在适当的情况下重复利用同一资源，prefetch 是为了导航到下一个页面时能够提前加载该页面的资源，但对当前页面并没啥助益，而且相对 preload 其优先级更低。

在资源加载过程中，我们也可以适当的使用**懒加载**和**预加载**技术，并为加载过程添加一些 loading 和 transition 动画效果，特别是首屏加载。或是生成**骨架页面（placeholder）**，甚至可以采用**服务端渲染（SSR）**以及**Service Woker** 来优化用户体验。

随着新版本的浏览器普及，以前的代码一律编译到 ES5 并加上 polyfill 的策略可以适当改变，比如编译到 ES2015 来提高代码运行效率，减少体积，在 2018 年，移动端 90% 用户的浏览器几乎都原生支持 class 等语法，因而我们只要为老旧浏览器用户保留一个 ES5 备胎即可，通过特性检测，比如`<script type="module">` 标签来识别，支持该标签的浏览器必然支持 ES2015 语法，如 Promise,、Class、箭头函数等，而不支持该标签的会因为无法识别这个标签而不去加载 ES2015+ 代码，也可利用 `nomodule ` 属性标识 ES5 版本代码，支持该属性的浏览器会忽略从而加载 ES2015的代码，不支持的则会加载它。

正确的使用 Webpack 的 Tree Shaking 和 SplitChunksPlugin，使用 Tree Shaking 来避免打包一些没有用到的代码，这样可以减少代码的体积，在 Webpack 4 以后 Tree Shaking 对无副作用的模块也会生效了，但需要在 `package.json` 中声明它无副作用，因而如果模块仅引用而没使用就会自动 Tree Shaking  掉，这对 lodash 等库的使用非常有意义。

当 HTTP 2 普及后，我们还有 **HTTP2 Server Push** 来推送资源，考虑到以后的 **WASM** 的普及，因为其传输的是二进制编译优化后的代码，可以直接转换成机器码执行，不需要像 JS 一样经过 parser 编译过程，这意味这更小的体积，更快的加载速度，以及更好的执行性能，后续的前端会精彩。 



### 重排与重绘

当页面发生**某些变化**的时候就会触发浏览器的重排(Reflow)与重绘(Repaint)，具体来来说，这些变化影响到了布局，渲染树需要重新计算，哪些变化会影响布局呢？常见的如 DOM 操作，窗口变化， CSS 属性变化等。

页面渲染的每个阶段都是要消耗时间的，为了更好的优化用户体验，通常可以从三个方面着手，**避免堵塞等待**，**减少渲染时间**，**JS代码优化**。

当 DOM 树中某一级发生变化时会影响所有层级，若是 DOM 层级太深，那么 Reflow 消耗的时间就会变长，所以编码时就要避免过深的 DOM 层级，编写合理简洁的页面结构。

**重排一定会重绘，反之则不一定**

不影响布局的改变只会触发重绘而不会触发重排，比如说只改变某个元素的颜色（背景颜色，文字颜色等）。另外一点，绝对定位的元素是脱离文档流的，因而重排时不受影响，对于一些动画和页面装饰可以用绝对定位。

### JavaScript 代码优化

* CCS 动画因为有 GPU 加持，因而性能会更好一些，所以尽量使用 CSS 动画来替代 JS 动画。
* DOM 查找和操作都是耗时间的，因而不要使用过于复杂的选择器，对于查找结果可以做缓存，减少 DOM 的操作次数，不要操作无关的 DOM。（这正是框架 Diff 算法做的）
* eval，with 等 JS 语法特性是不推荐使用的，因为这会影响 V8 引擎的代码优化，同时也是不安全的。
* 前端也好后端也罢，提高性能那就是缓存，缓存，各种花式缓存，使用 Service Worker 代理所有请求，用 **CacheStorage**  缓存。对于一个遵循 Restful 风格的接口而言，其 get 请求应该是幂等且无副作用的，因而我们可以在前端**对接口调用做缓存**，将结果存入 **localStorage** 或是 **sessionStorage**。进一步，如果我们遵循函数式编程，那么函数记忆化（memoization），惰性求值（Lazy Evaluation）等许多函数式编程实践都是提升性能的方式。

