---
Title: JS任督二脉-作用域 
Tags: 编码 | 前端 
PublishDate: 2015/12/8 22:40 
---

# 引言  
多数人初次使用JavaScript的时候，恐怕都将其作为一种粘合剂使用，用诸如JQuery之类的库来控制页面为，与后端交互等。
当然，这并没有错，这门语言在设计之初就是如此考虑的，但是随着Web技术的发展，JS却出乎意料的成为了浏览器语言的最终胜利者，并被各大浏览器支持，性能也得到了质的提升，隐隐有成为浏览器上的汇编语言这一趋势，出现了诸多以JS代码作为编译目标的语言，如CoffeeScript，TypeScript。

随着Node.js等一系列的技术出现，JS的领域甚至被拓展至了浏览器之外，如React-Native开发ios、Android应用，GitHub开发的Atom编辑器，即便是在Web端，随着各种前端框架、工程化工具的不断涌现，JS也越来越受到重视，现在JavaScript已经成为了世界上使用最广泛的软件平台，互联网的核心技术。

**是时候严肃认真的学习它了，深入才能察觉深度，当你学习诸如闭包，this，作用域链，原型链等概念的时候，你会发现JS并不简单！**

# 作用域与原型
## 作用域
为什么称其为JS的任督二脉？与之相关的概念有作用域链、原型链，而JS中那些最复杂的概念，如闭包等概念其实都在建立在这两套机制之上的，可以说理解了JS的作用域与原型，就掌握了JS精髓的70%!，也只有理解了这两个概念，才能从容自信的使用JS中的各种魔法，或是处理各种奇怪的问题。
作用域一词从字面上来理解，即代码中标识符被限定的可见范围，某些标识符并不总是可见的，会因为声明位置的不同而有所差异。这里说的标识符，最直观的例子就是变量，几乎所有非纯函数式语言都会提供这样一个基本功能，那就是声明变量来存储值，并可以通过名字进行访问，修改值，正是这一功能引入了*状态*，才使我们开发变得易于理解，但也带来了副作用。
我们知道，变量的值存储在内存中，但在代码编译时，编译器又是根据什么规则去寻找相关变量的值呢？
这里的规则就是*作用域*，这套规则用来确定在何处、如何查找标识符。
作用域一般分两种模型，词法作用域与动态作用域两种，在JavaScript中采用的是词法作用域，这意味着代码中每个标识符的作用域是运行前就确定的，并且其作用域取决于你声明它们的位置，编译器在词法分析阶段就能基本能确定所有表示符的所在位置与声明方式，以及其作用域。
![函数声明的局部作用域](http://upload-images.jianshu.io/upload_images/54452-f2d0c60a563d39ea.png?imageMogr2/auto-orient/strip%!CimageView2/2/w/1240)
图中我们通过声明函数创建了一个函数作用域，这个作用域分为三层嵌套：
1. 包含foo这个函数名字的全局作用域
2. a、b、bar组成的函数作用域
3. c 组成的作用域

这些作用域的嵌套，形成了作用域链的概念，即里层作用域中的标识符若无法访问到，就会逐级向上层作用域寻找，直到找到第一个为止。但反过来就不行，上层作用域无法查早下层作用域的内容，在多层嵌套的作用域中可以声明同名的标识符（内层标识符遮盖外层同名标识符），这就是**遮蔽效应**。

在全局作用域中声明的变量，自动成为全局对象的属性，如果是在浏览器中，foo()就是windows的属性，可以通过windows.foo直接访问。

在JavaScript中存在两类作用域，全局作用域和局部作用域，作用域的意义是显而易见的，典型如避免名字污染的问题，在ES6之前，函数是JavaScript中最一般的作用域单元，称之为函数作用域，但函数并不是唯一的作用域单元，在ES6中又新增了块级作用域，可以采用大括号的方式来创建，并使用let,const的方式声明块级作用域的变量，实际上还有一些特殊的作用域，如try/catch也会创建一个块级作用域。

虽然JavaScript采用的是词法作用域模型，但是却有在运行时修改作用域的方法，但并不推荐使用，会为编译器的分析带来困难，导致明显的性能下降。
典型如 **eval()** 函数，它接受一个字符串为参数，并将其中内容视为在当前位置声明的JavaScript语句，并执行。

```
function foo(str, b) {
  eval(str);
  console.log(a, b)
}
var a = 0;
var str = 'var a = 1;';
foo(str, 2); // 1, 2;
```
我们可以很轻松的在程序运行时拼接字符串传入，达到修改eval处作用域的目的，但在严格模式下，eval函数无法修改所在位置的作用域。
### with 关键字
with通常作为重复使用同一对象属性时的快捷方式。
```
var obj = { a: 1, b: 2};
obj.a = 2;
obj.b = 3;
//.... 这样太麻烦了， 简单版
with (obj) {
 a = 1;
 b = 2;
}
```
但是，当我们传入的对象没有相对应的属性时，
```
var obj2 = {};
with (obj2) {
  a = 1; // obj2 对象没有a属性
}
```
这里a在非严格模式下被创建为全局属性，泄露出去了。
实际上with 创建了一个完全隔离的词法作用域，这个对象的属性也会被处理为定义在这个作用域中的词法标识符，但是其中的var声明并不会限制在这个作用域中，而是添加到了with所在的函数作用域中。
以上两个典型例子所用的关键字都是典型不推荐使用的，相比稀有的使用场景，不使用带来的性能提升更值得。

### 变量提升
```
a = 2;
var a;
console.log(a);  // 2
```
这段代码可以执行，但是有一点反直觉，因为 a 的赋值在声明之前，这应该会报ReferenceError，或者a输出为undefined才对。
再看一个例子：
```
console.log(a);
var a = 2;
```
这里console.log输出的是undefiend，尽管变量在声明前被使用，但是却并没有报ReferenceError。
实际上在JavaScript中，包括变量和函数在内的声明，都会在被提升至行首先处理，而且函数的优先级高于变量。

### 闭包
在JavaScript中声明函数是创建作用域最典型的方式，当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时 就产生了*闭包*，利用闭包可以隐藏实现、规避名字冲突、模块化，具体用法网上随便搜一堆。
那么函数如何记住并访问所在的词法作用域呢？这涉及到作用域链的原理。

### 作用域链原理
> “JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里.”   ---《Javascript权威指南》

**Execution context stack**

> 每个函数在被调用时都会创建自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECSMScript程序中的执行流正是由这个方便的机制控制着。

也就是说，ECMAScript程序的运行时就是由执行上下文（EC）组成的栈，*栈顶*是当前*活跃*(active)上下文：
![](http://s0-weizhifeng-net.b0.upaiyun.com/images/tech/ec-stack.png)

**Execution context**
函数在执行的时候会创建一个执行环境（execution context）或称执行上下文， 执行环境定义了变量和函数的访问其他数据的权限。

![](http://upload-images.jianshu.io/upload_images/54452-0d9dfa7d11533c0e.png)

**VO && AO**
每个执行环境都有一个与之关联的变量对象，在全局执行环境中的是** VO **(Variable Object)，但是在函数的执行上下文中,变量对象是以活动对象**AO**（activation object）来表示的。（在ECMA-262-5中统一并入了*词法环境*模型 lexical environments model）

在函数环境中定义的所有标识符都存储在这个AO对象内，它包括：
* 变量声明 (var, VariableDeclaration)
* 函数声明 (function declarations)
*  形参  (function formal parameters declared in the context)

**scope chain**

> 作用域链（scope chain）是一个变量对象列表，上下文代码中出现的标识符在这个列表中进行查找。

每个函数被定义的时候都会创建一个** [[scope]] ** 属性，它会将定义时的scope chain存入这个属性中。

一个函数被调用的时候，活动对象（AO）将会被创建，然后对于每一个函数的形参，都命名为该活动对象的命名属性，这个对象中除了形参还有arguments对象，之后AO将作为函数执行上下文的变量对象使用，
同时将这个活动对象做为此时的作用域链(scope chain)最前端, 并将这个函数对象的[[scope]]加入到scope chain中。
**scope chain = AO + [[scope]]**

当解析一个标识符的时候，会从作用域链中的第一个对象（即活动对象）开始查找，如果这个标识符在函数自身的活动对象中没有被查找到，就去作用域链的下一个对象中去查找，如此重复这个过程。

### this
> this是一个与执行上下文相关的特殊对象。因此，它可以叫作上下文对象（也就是用来指明执行上下文是在哪个上下文中被触发的对象）。

有一点特殊的是，this 是基于运行时的执行环境动态绑定的，而非定义时的环境（ES6的=>箭头函数除外），
在全局上下文中，this就等于*全局对象本身*（这意味着，这里的this等于*变量对象*），而在函数调用中，this的情况会根据调用的方式呈现多种情况，通常情况下，函数调用时的this是由父上下文(parent context )提供，那调用方式究竟是如何影响this？这又涉及到一个内部类型——引用类型（the *Reference* type）。

引用类型的值可以用伪代码表示为一个拥有两个属性的对象——*base*属性（属性所属的对象）以及该base对象中的*propertyName*属性：
```
var valueOfReferenceType = { 
base: , 
propertyName: 
};
```
引用类型的值只有可能是以下两种情况：
**当处理一个标识符的时候**
**或者进行属性访问的时候**

标识符就是变量名，函数名，函数参数名以及全局对象的未受限的属性。
如下所示：
```
var foo = 10;
function bar() {}
// 对应的引用类型的值如下所示：
var fooReference = {
  base: global,
  propertyName: 'foo'
};
 
var barReference = {
  base: global,
  propertyName: 'bar'
};
```
要从引用类型的值中获取一个对象实际的值需要*GetValue*方法，对于属性访问来说，有两种方式： 点符号（propertyName就是点的左侧，使用这两种方法时都讲确定属性名）或者中括号符号。

**函数上下文中this的值是函数调用者提供并且由当前调用表达式的形式而定的：**
 1. 如果在调用括号()的左边，有引用类型的值，那么this的值就会设置为该引用类型值的base对象。
 2. 所有其他情况下（非引用类型），this的值总是*null*，由于null对于this来说没有任何意义，于是在非严格模式下就被隐式转换成了global，严格模式下则是undefined。

有一种特殊情况，当调用表达式左侧是引用类型的值，但引用类型的值base对象恰好为AO**活跃对象**时，this也会是null，因为活跃对象总是会返回this值为——null（用伪代码来表示，AO.bar()就相当于null.bar()），于是this的值最终会由null变为全局对象或者undefined。
```
function foo() {
  function bar() {
    alert(this); // global
  }
  bar(); // 和AO.bar()是一样的
}
```
- - -
文档参考 [ECMA-262JavaScript The Core](http://dmitrysoshnikov.com/ecmascript/javascript-the-core/)
​    