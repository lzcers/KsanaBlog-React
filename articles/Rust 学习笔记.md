---
Title: Rust 学习笔记
Tags: 编程
PublishDate: 2018/8/6 19:25:28
---



### 为什么学习 Rust ？

* 宏
* 采用所用权系统来避免 GC 保障内存安全（**好奇**）
* 零开销抽象性能高，又有很多现代编程语言的特性
* 官方对 WebAssembly 支持度高，编译到 WASM 很方便
* **不折腾不舒服斯基**

相对于 Go 来说，Rust 的概念还是蛮多的，怎么学一门新的编程语言呢？如果有其它编程语言的经验，那么学习一门新的编程语言是比较容易的，学习过程更多的是知识迁移而不是熟悉新的概念，如果是学习新的编程范式则会比较困难，这不仅仅是学习新的概念，还需要在思维模式上做出改变，对于编程语言的学习，因该多去学习不同范式的语言，尽管现代编程语言都支持多范式，但各语言擅长的范式还是不一样的。

无论如何，不同编程范式的语言都有通用的编程概念，迅速找到这些**通用概念**在该语言中的表达方式就能快速上手写代码了，比如`变量声明、数据类型、控制流、函数`，然后再去学习这些语言里的独特的概念并付诸实践。要把代码写好，还是需要付出精力去学习这门语言的优秀实践。

后续会持续学习 Rust ，并补充笔记，然后写一个 Rust 编译到 [WwebAssembly](https://developer.mozilla.org/zh-CN/docs/WebAssembly) 的例子。

## 基本的表达方式

### 声明

`let` 声明绑定，所有值默认是不可变的，需要通过 `let mut`来声明可变性。

也可以利用 `const` 声明常量，其作用更类似于 `define` 定义个大范围，多处使用的值。

Rust 采用 snake case 风格声明变量和函数名，也就是小写字母加下划线分隔。

`//` 声明代码注释，还有一种文档注释

### 数据类型

Rust 中将内建的类型分为两类：标量（scalar）和复合（compound）

* 标量： 整型、浮点型、布尔型、字符型

  整数默认是 i32，浮点数默认是 f64，`char` 字符类型，用单引号指定，不同于双引号指定的字符串，Rust 中的`char` 是一个 Unicode 标量值，这意味着比 ASCII 更大的表示范围。

  `isize` 和 `usize` 类型依赖运行程序的计算机架构，64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。

* 复合：元组（tuple）和数组（array）

  元组的元素可以是多类型，数组的元素类型必须是一样的，都是定长不可变的，可以使用模式匹配来解构。

  ```rust
  let x: (i32, f64, u8) = (500, 6.4, 1); // 元组声明
  let five_hundred = x.0; // 索引访问
  let a = [1, 2, 3, 4, 5]; // 数组声明
  let first = a[0]; // 数组访问
  ```

### 函数

Rust 中的函数定义先后不影响调用（类比于 JS 的提升），main 函数是程序入口，如果没有显式 `return` 返回，则默认以最后一个表达式的值作为返回值。Rust 是基于表达式的，`{}`也是表达式，会返回最后一个表达式的值，如果最后一个表达式加上了分号，就会变成语句了。

### 控制流

* **if** 表达式后跟一个条件，条件必须是 bool 值，if 表达式是有值的，因而可以放在 let 后面，但此时要注意两个分支的返回值类型是否一致，否则会报错。
* **loop、while** 前者是无条件无限循环，后者是条件循环，`break` 中断。
* **for in** 遍历集合

## 组合

## 抽象

**!** 结尾的函数调用都是宏调用，比如 `println!();`

### 所有权

区别于其它语言的一个重要特性，简单来说通过所有权模型可以避免带 GC 的垃圾回收，从而获得更高的性能，当然，也更麻烦，它的规则很简单。

1. Rust 中每一个值都有一个称之为其 **所有者**（*owner*）的变量。
2. 值有且只能有一个所有者。
3. 当所有者（变量）离开作用域，这个值将被丢弃。

也就是说所有值都有一个一个 Owner ，当它离开作用域时就会被回收，也就是确定性析构，离开作用域的方式可能是`赋值（非clone）、函数传参与返回`，这种方式称为**移动**，通过克隆可以避免所有权因为移动而丢失，放在栈上的数据如果带有 **copy** 的类型是不会因为赋值丢失所有权的，如 `u32、bool、f64、元祖(包含的类型都是 copy 时)`等。

因为函数的传参与返回都会导致所有权移动，这会显得很麻烦，因而可以通过传递引用来避免，但传递引用只允许使用引用的值，而不能修改它（会报错），获取引用作为函数参数称为**借用（borrowing）**，它是**没有所有权**的 ，若要修改引用值，还是需要加上 `mut`声明为可变引用，而且这还有限制，在特定作用域中，只能有一个引用，这就避免了**数据竞争**（*data race*），当然，我们可以用大括号再声明一个作用域，而且我们也不能同时拥有可变引用和不可变引用，真是简单粗暴。

```rust
let mut s = String::from("hello");
let r1 = &s; // no problem
let r2 = &s; // no problem
let r3 = &mut s; // BIG PROBLEM
```

关于引用，总结来说就是：

在任意给定时间，只能 拥有如下中的一个：

1. 一个可变引用；
2. 任意数量的不可变引用；
3. 引用必须总是有效的；

## 工具

### cargo

`cargo new` 创建项目

`cargo check` 编译检查

`cargo build`  编译、构建

`cargo build --release`  构建发布版本

`cargo run` 编译、构建、执行



