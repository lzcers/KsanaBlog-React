---
Titile: 从浏览器工作机制看性能优化
Date: 2018/7/9 15：31
Tags: 前端
---

# 背景

之前学习前端过程中做了不少关于性能优化的笔记，但是大多都太零散，无法串联起来，便想写一篇文章将所以知识点串起来，从浏览器的关键渲染路径来看性能优化是非常适合的，当然，前端的性能优化也不仅仅是这些，还有一些后端的优化工作也是非常有效的，决定页面用户体验不仅仅是前端，还有后端的协同工作。

# 浏览器渲染过程

## URL 解析

1. 用户输入 URL

2. 从URL 中解析出主机名

3. DNS 查询解析出主机名对应的服务器 IP

   先查本地 DNS 缓存记录 （比如 hosts 文件），没有再向 DNS 服务器查询，并将结果缓存

4. 根据 URL 提供的端口号（默认 80）请求服务器获取静态资源

   经过三次握手建立 TCP 连接，然后开始传输 HTTP 报文 （Request，Response），HTTP 协议是应用层协议，建立在 TCP/IP 协议上。

5. 关闭连接，浏览器开始解析文档

6. 如果文档中涉及其他资源则重复以上动作，直至所有资源加载完毕

## 页面渲染

![](..\imgs\browserRender.webp)

1. 处理 HTML 标记并构建 DOM 树。

   深度优先遍历过程，默认遇到 script 回解析执行其中的脚本，并堵塞渲染。（加上 defer,  async 属性可以控制执行 javaScript 的执行时间）

2. 处理 CSS 标记并构建 CSSOM 树。

3. 将 DOM 与 CSSOM 合并成一颗渲染树（Render Tree）。

   渲染树并不意味着就是 DOM 树，比如 Head，Display: none 等元素就不用放在这个里面。

4. 根据渲染树来布局，以计算每个节点的几何信息。（Layout、Flow）

5. 将各个节点绘制到屏幕上。（paint）
   postion 属性设为 absolute 或 fixed 等使得元素脱离文档流，它的变化不会影响其他元素，这样就可以避免重排，从而减少重绘（Repaint）。

## 从浏览器渲染机制来看性能优化

### 解析与堵塞

我们知道 HTML 解析过程中遇到 `<script>` 标签时，浏览器会立即加载并解析执行其中的代码，导致堵塞渲染，因而将 Script 标签放在末尾是常见的一种优化技巧，在比较新的浏览器上我们也可以为 script 标签加上 defer 和 async 属性，从而控制 JavaScript 的执行实行。

![wfL82.png](..\imgs\scriptload.webp) 

`<script src="main.js"></script>`

浏览器在解析到该标签时会立即加载并执行其中的脚本，在执行 JS 过程中会堵塞接下来的解析过程，因而 `<Script>`若是放在文档头部，如果 JS 的执行时间过长就会出现的白屏现象。事实上，为了更好的用户体验，现代浏览器通常不会等到渲染树出现了才开渲染，部分内容也会被解析显示，浏览器能够渲染不完整的 DOM树和 CSSOM ，进而缩短首屏（First Paint）的白屏时间。

`<script src="m2.js" defer></script>`

通过 `defer` 属性可以将将本的执行时间推迟到所有元素解析完成后，`DOMContentLoaded`  事件触发之前。

`<script src="m3.js" async></script>`

加载完后就立即执行，适用于那些无依赖的脚本。

***DNS 预解析***
```html
<link rel="dns-prefetch" href="//xxx.com">
```
DNS 的解析也是消耗时间的，因而在涉及多个域名的情况下，可以使用 DNS 预解析。


### 资源的加载

浏览器对资源的加载是并行的，但是不同浏览器对于同一域名的并发数量是有限的，我们看到很多大站会将静态资源下放到不同的子域名或是 CDN 上去，这样做的好处是

* 突破浏览器的并发限制
* CDN 能自动选择优质节点加快传输速度，减少源站的压力
* Cookie 静态资源请求不带 Cookie 减少传输压力

除了这些举措，通常的优化策略**减少请求数量**，**减少请求的体积**，都是在浏览器的资源加载上发力。

* 减少请求数量： 打包CSS，JS，图片，开启缓存，使用CDN

* 减少请求体积： 压缩CSS，JS，图片或转base64，开gzip

除此之外我们还可以使用 HTML5 的属性，**Preload**、**Prefetch**，让浏览器在空闲时提前准备资源。

```html
<link rel="prefetch" href="main.js">
// 浏览器会在空闲时下载文件并缓存，使用时直接从缓存取。
<link rel="preload" href="/main.js" as="script">
// 提前加载好脚本但不执行，遇到 main.js 时直接执行。
```

适当的使用**懒加载**和**预加载**技术，为加载过程添加些适当加一些 loading 和 transition 效果动画效果，生成**骨架页面**，甚至可以采用**服务端渲染（SSR）**以及 **PWA** 。

### 重排与重绘

当页面发生**某些变化**的时候就会触发浏览器的重排(Reflow)与重绘(Repaint)，具体来来说，这些变化影响到了布局，渲染树需要重新计算，哪些变化会影响布局呢？常见的如 DOM 操作，窗口变化， CSS 属性变化等。

页面渲染的每个阶段都是要消耗时间的，为了更好的优化用户体验，采取的策略就是从三个方面开始，**避免堵塞等待**，**减少渲染时间**。

当 DOM 树中某一级发生变化时会影响所有层级，若是 DOM 层级太深，那么 Reflow 消耗的时间就会变长，所以编码时就要避免过深的 DOM 层级，编写合理简洁的页面结构。

**重排一定会重绘，反之则不一定**

不影响布局的改变只会触发重绘而不会触发重排，比如说只改变某个元素的颜色（背景颜色，文字颜色等）。另外一点，绝对定位的元素是脱离文档流的，因而重排时不受影响，对于一些动画和页面装饰可以用绝对定位。

### JavaScript 代码优化

* CCS 动画因为有 GPU 加持，因而性能会更好一些，所以尽量使用 CSS 动画来替代 JS 动画。
* DOM 查找和操作都是耗时间的，因而不要使用过于复杂的选择器，对于查找结果可以做缓存，减少 DOM 的操作次数，不要操作无关的 DOM。（这正是框架 Diff 算法做的）
* eval，with 等 JS 语法特性是不推荐使用的，因为这会影响 V8 引擎的代码优化，同时也是不安全的。

