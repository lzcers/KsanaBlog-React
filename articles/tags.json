[
  {
    "fileName": "雨.md",
    "ID": 0,
    "Title": "雨",
    "Tags": "碎念",
    "PublishDate": "2017/7/17 14:43:00",
    "Content": "\r\n![](http://imglf2.nosdn.127.net/img/UUcvQWZBZk9URHhUNmthQzQxSXpDWExXNkhtMXNxK0VTemVWL3FMZTcwZ0hJckcyTDVRQTF3PT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\r\n狂风暴雨下撑伞并没什么用，还不如一件雨衣来得实在。\r\n    <strong>……</strong>"
  },
  {
    "fileName": "通过gitHub与Issues构建博客.md",
    "ID": 1,
    "Title": "通过gitHub与Issues构建博客",
    "Tags": "碎念",
    "PublishDate": "2017/7/16 19:20:56",
    "Content": "\r\n![](http://imglf0.nosdn.127.net/img/UUcvQWZBZk9URHhUNmthQzQxSXpDWlhMeitBckdwOVhzNEZtb05xSndtaXowOHpKNEJyREd3PT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)  \r\n简单来说就是在Issues里写博文，通过官方提供的API来获取数据，然后再由前端的MD解析器动态渲染到页面上。  \r\n\r\nAPI:https://developer.github.com/v3/issues/\r\n    <strong>……</strong>"
  },
  {
    "fileName": "通过acme.sh申请Let's Encrypt证书.md",
    "ID": 2,
    "Title": "通过acme.sh申请Let's Encrypt证书",
    "Tags": "编码",
    "PublishDate": "2017/8/27 17:43:02",
    "Content": "\r\n已经可以看到很多网站都启用了https，这年头丢个http的链接出去都有点不好意思了，当然，HTTPS的好处也不仅是好看这么简单，相较于HTTP，它带来的最直接好处就是你再也不用担心恶心的运营商劫持并植入广告了，还有被GFW墙掉的风险，你担心网页打开速度？SPDY 和 HTTP2 目前的实现默认使用 HTTPS 协议。  \r\n\r\n现在各大浏览器厂商也开始对非HTTPS站点标记不安全标识，同时搜索引擎也开始降低非https网站的权重，国内各大网站已经全面上HTTPS了。我这种小博客也寻思着如何追赶潮流，但是证书是要钱滴，而且级别越高价格越贵，好在有Let's Encrypt这个免费颁发DV证书的CA，看到SPONSORS里一堆大佬，所以应该是挺可靠的。虽然提供的证书有效期短，但是借住acme.sh这个国人开发的工具，可以很方便的自动申请并更新证书，因此尽管放心使用好了。\r\n\r\n[acme.sh](https://github.com/Neilpang/acme.sh)是一个实现了ACME协议的linux命令行工具，那在windows上咋用？如果你是win10，那么安装Ubuntu子系统即可，具体使用看官方文档。<strong>……</strong>"
  },
  {
    "fileName": "超酷炫的字体.md",
    "ID": 3,
    "Title": "超酷炫的字体",
    "Tags": "碎念",
    "PublishDate": "2017/8/8 20:53:41",
    "Content": "\r\n![](http://imglf.nosdn.127.net/img/UUcvQWZBZk9URHhpYitWU1daWjRPVitUdXJSWFZHZ3h2S2ZOd1NoZGZ4SjhUSEx2ZUdNaDJRPT0.png?imageView&thumbnail=500x0&quality=96&stripmeta=0&type=jpg)  \r\n\r\n如图，**Iosevka**是一个非常酷炫与性感的开源的字体。  \r\n没错！它是用代码生成的, 非常适合Coding，  \r\n使用之后，感觉Coding有神奇的Buff加成！  \r\n截图可能不够清晰，但实际效果是非常棒的！  \r\n[View Specimen](https://be5invis.github.io/Iosevka/specimen.html)  \r\n[Iosevka GitHub](https://github.com/be5invis/Iosevka)\r\n    <strong>……</strong>"
  },
  {
    "fileName": "读《原则》.md",
    "ID": 4,
    "Title": "读《原则》",
    "Tags": "读书",
    "PublishDate": "2018/5/29 00:31",
    "Content": "\r\n又不知道从哪篇博文里看到了《原则》这本书的推荐，习惯使然上豆瓣看了下评论，分数达 8.5 分让人意外，老实说，对于这种书名和介绍我会想当然将其归类为成功学、鸡汤便不再理会，不过作者确实是成功人士，或许某些观点也值得学习下。花了两晚上时间囫囵吞枣似的看完，做了写摘录，书中许多观点是很有价值的。\r\n\r\n## 原则\r\n\r\n> 思考，总结提炼原则，并且知行合一的实践原则，同时保持谦逊使得大脑更加开放和包容。\r\n>\r\n> 1. 独立思考并决定 \r\n> 2. 以可信度加权的方式做决定\r\n> 3. 遵照原则做事\r\n\r\n不仅要独立思考，同时要要保持谦逊和心胸开阔，才能动用自己的最佳思维，在肯定自己是对的之前，还要知道自己为什么是对的，对自己想法的肯定应该来自于事实，而非自以为是。\r\n\r\n## 投资\r\n\r\n> 股价反映的是人们的预期，当实际结果比预期好时，股价会上涨，反之则跌。<strong>……</strong>"
  },
  {
    "fileName": "裸辞.md",
    "ID": 5,
    "Title": "裸辞",
    "Tags": "碎念",
    "PublishDate": "2017/12/6 20:28:16",
    "Content": "\r\n当初我一个人来，现在要走了，却是除了回忆什么也带不走，很多的人和事也早已只能从回忆里寻找了，最后，我也把自己也活进了回忆里。这是计划中的离职，从入职的时候就考虑过的离开，只是离职的理由并非我最初所想的那样，一直身体硬朗的父亲年中突发脑溢血，尽管愈后精神不错，却丧失了大部分语言能力，行动也不便，如此结果也依旧要感谢上天保佑了，但愿父亲能够恢复的更好。父母在不远游，游必有方，本以为能在深圳多呆几年，但现在不光是离职的日程提前了，今后几年在哪工作也需要有所调整，作为家中独子，我必须在家人和事业二者间找到一个平衡点，以便于最大程度上兼顾。父母健康的时候我可以为自己找各种理由不回去，回顾在深圳的三年仅回去了三次，内心不免有些愧疚，离家远吗？ 仅 4 小时的高铁车程，说远也不见得，离职在计划之中，而原因却是意料之外，无论之后作何打算，先回家陪陪父母，这是最重要的。\r\n<strong>……</strong>"
  },
  {
    "fileName": "蛤丝(Haskell)学习.md",
    "ID": 6,
    "Title": "蛤丝(Haskell)学习",
    "Tags": "编程",
    "PublishDate": "2018/6/19 23:42",
    "Content": "\r\n知乎上关注的很多前端大佬都是函数式编程玩的贼 6 的那种，动不动就贴 Haskell 代码，就想学习下蛤丝（Haskell）语言，增长点姿势，尽管之前玩 Lisp 有一点点函数式编程的体验，但是 Haskell 的类型和惰性求值还是要感受下的。\r\n\r\n从 [Haskell 趣学指南](http://fleurer.github.io/lyah/) 开始，不得不说，语法糖真是好吃啊，代码还能这样写。\r\n\r\n```haskell\r\nquicksort :: (Ord a) => [a] -> [a]   \r\nquicksort [] = []   \r\nquicksort (x:xs) =   \r\n  let smallerSorted = quicksort [a | a <- xs, a <= x]  \r\n       biggerSorted = quicksort [a | a <- xs, a > x]   \r\n  in smallerSorted ++ [x] ++ biggerSorted\r\n```\r\n\r\n上一段 Haskell 的快排算法，卧槽，还能这么写，` [a | a <- xs, a <= x] ` 像数学一样定义作用域，在 List 里直接做过滤和取值，Cool !， 写过 python 肯定知道列表推导，相比而言这个简直强太多了，还能在 List 里做模式匹配。\r\n\r\nJS 不是也能函数式编程嘛，翻一下\r\n\r\n```javascript\r\nfunction quickSort(arr) {\r\n    if (arr.length == 0) return []\r\n    let i = arr[0]\r\n    const smallerSorted = quickSort(arr.slice(1).filter(e => e <= i))\r\n    const biggerSorted = quickSort(arr.slice(1).filter(e => e > i))\r\n    return [].concat(smallerSorted, i, biggerSorted)\r\n}\r\n```\r\n\r\n加上类型签名，代码行数好像差不多？？不过字符数量少呀。\r\n\r\n\r\n\r\n**fold**\r\n\r\n`Foldable t => (b -> a -> b) -> b -> t a -> b`\r\n\r\n一个fold取一个二元函数，一个初始值（我喜欢管它叫累加值）和一个需要fold（折叠）的list。<strong>……</strong>"
  },
  {
    "fileName": "自由.md",
    "ID": 7,
    "Title": "自由",
    "Tags": "随想",
    "PublishDate": "2017/7/30 22:43:40",
    "Content": "\r\n![](http://imglf.nosdn.127.net/img/UUcvQWZBZk9URHhUNmthQzQxSXpDYktvemtFZ1RPNHVlWHNjZFZSVWRZWjhEejc1L2RWRk5RPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)  \r\n人生的目的或许是为了追求自由吧，各种意义上的自由，你的工作为你带来了一定程度的消费自由，但你期望更多财务自由，为此而更加努力的工作着。  \r\n你喜欢看书，你获取知识，摄取理性，这使得你的精神和思想得以解放，这是对精神自由的追求。  \r\n所有的勤勉与努力，或多或少就是内心对自由的向往吧，这种对自由的渴望，仿佛是没有止境一般，因为存在，就是最大的约束。\r\n\r\n    <strong>……</strong>"
  },
  {
    "fileName": "编译原理学习.md",
    "ID": 8,
    "Title": "编译原理学习",
    "Tags": "编程",
    "PublishDate": "2018/5/27 23:26",
    "Content": "\r\n关于语言，首先要正确区分语法和语义\r\n\r\n# 语法的形式\r\n\r\n语法的形式一般用一集规则描述，而这个语言的表达能力也跟选取的规则不同。\r\n\r\n通常，基于最简单的三个规则，*拼接*、*选择*，*任意次数重复*即可构成一种一种**正则语言**，为了使表达能力更为强大，我们可以加入递归，从定义一种**上下文无关语言**。\r\n\r\n仅使用*拼接*、*选择*、*重复*三个规则我们就能定义所有的单词。\r\n```\r\ndigit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\r\nunsigned_integer -> digit digit*\r\n```\r\n上面是一个关于数字的定义，其中 | 意思是选择，* 代表任意次重复，这样一条规则称之为一个产生式，箭头左边的字符串称之为非终结符，由这样一个产生式导出来的字符串称之为终结符。\r\n\r\n对于描述一个程序设计语言而言，仅仅是这三条规则是远远不够的，我们还要加入**递归**。<strong>……</strong>"
  },
  {
    "fileName": "用JS 实现 Lisp 里的流.md",
    "ID": 9,
    "Title": "用JS 实现 Lisp 里的流",
    "Tags": "编程",
    "PublishDate": "2018/3/10 21:24:59",
    "Content": "在 Lisp 我们这样实现\r\n``` lisp\r\n(define-syntax-rule (delay exp) \r\n    (memo-proc (lambda () exp)))\r\n(define-syntax-rule (cons-stream a b) \r\n  (cons a (delay b)))\r\n(define (stream-car stream) (car stream))\r\n(define (stream-cdr stream) (force (cdr stream)))\r\n(define the-empty-stream '())\r\n(define-syntax-rule (force delayed-object)\r\n  (delayed-object))\r\n(define (stream-null? stream)\r\n  (if (equal? stream the-empty-stream)\r\n      #t\r\n      #f))\r\n(define (stream-ref s n)\r\n  (if (= n 0)\r\n      (stream-car s)\r\n      (stream-ref (stream-cdr s) (- n 1))))\r\n```\r\n\r\n在 JavaScript  这样子\r\n``` javascript\r\nconst cons = (x, y) => [x, y]\r\nconst car = p => p[0]\r\nconst cdr = p => p[1]\r\nconst delay = (f, args) => _ => f.apply(this, args)\r\nconst force = f => f()\r\nconst consStream = (x, y, args) => cons(x, delay(y, args))\r\nconst streamCar = s => car(s)\r\nconst streamCdr = s => (force((cdr(s))))\r\nconst streamRef = (s, n) => n == 0 ? streamCar(s) : streamRef(streamCdr(s), --n)\r\n// 定义自然数组成的流\r\nconst interStaringFrom = n => consStream(n, interStaringFrom, [++n])\r\nconst intNumber = interStaringFrom(1)\r\n// 定义斐波拉契数列流\r\nconst fibgn = (a, b) => consStream(a, fibgn, [b, a + b])\r\nconst fibs = fibgn(0, 1)\r\n// 取费波拉契数列 100项\r\nstreamRef(fibs, 100)\r\n```\r\n\r\nScheme 使用的求值顺序是应用序，意味着函数的参数在调用时就会求值，所以 delay 是一个特殊形式，需要用宏来实现，否则就会陷入死循环。其中大部分代码都可以简单转写成 JS 的代码。但是在 JS 中没有宏这样的玩意咋办？ 简单点，我们可以曲线救国，对 consStream 的构造方法做一些修改，利用 `f.apply(this, args)` 来实现 delay，JavaScript中的迭代器和生成器也是一种类似思维的实现。\r\n\r\n流能做啥？如果我们需要对真实世界的各种对象进行模拟该如何办，从计算机的角度考虑，理所当然就是考虑引入赋值，通过变量的修改来模拟对象状态随时间变化，引进赋值可以增强系统的模块化，把一个系统的某些状态封装到不同的对象中去，那是否有不采用赋值的方式，从而模拟对象状态变化的方法呢？流就是这样一种方法，它能提供相同的模块化能力，而且不必引入赋值，从函数的思路来看，我们可以将状态看作是时间的函数，s(t)，如果将注意力集中在状态身上，那么它就一个不断变化的值，但是从状态的变化的整个历史上来看，可将其视为一个整体，所以从整体上来看是不变的。\r\n\r\n现在前端流行的 React 框架采用了函数式的思路，即 Render(State) => View，将视图看作是状态的计算结果，既然采用函数式范式，那么就要尽可能的使用不可变量，于是理所当然的使用了单向数据流的模式。<strong>……</strong>"
  },
  {
    "fileName": "用 JS 撸个 LISP 解释器（3）.md",
    "ID": 10,
    "Title": "用 JS 撸个 LISP 解释器（3）",
    "Tags": "编程 | 坑",
    "PublishDate": "2018/6/10 23:58",
    "Content": "\r\n\r\n\r\n接上回，我们已经实现了一个基于 S 表达式的计算器，但还留下了这些坑\r\n\r\n* 变量绑定\r\n* 函数声明与调用\r\n* 闭包\r\n\r\n这几个特性对于一个编程语言而言是非常重要的，so...开始填坑吧\r\n\r\n## 变量绑定\r\n\r\n```\r\n<BODY> -> <DEFINE>* EXP <EXP>* \r\n<BINDSPEC> -> (<VAR> <EXP>)\r\n<LET> -> (let (<BINDSPEC>) <BODY>) | (let <VAR> (<BINDSPEC>) <BODY>)  \r\n```\r\n\r\n语法形式就从 Scheme R5RS 上抄好了，解析过程就不再另外写，基于 Parser Combinator ，在之前的例子上扩展就行，但是环境的定义有些改变，因为我们要实现词法作用域，现在我们的环境是由对象组成的数组。从下标 0 开始对应当前环境，1 对应外层环境，依次嵌套下去，就像 Express / KOA 的洋葱模型一样，从里到外。并实现了一个 lookup 方法用于在环境中寻找给定符号的值，这个查找过程可以类比于 javaScript 的作用域链查找。\r\n\r\n```javascript\r\n// 定义环境\r\nconst baseProcedure = {\r\n  '+': args => args.reduce((pre, cur) => cur + pre),\r\n  '-': args => args.reduce((pre, cur) => cur - pre),\r\n  '*': args => args.reduce((pre, cur) => cur * pre),\r\n  '/': args => args.reduce((pre, cur) => pre / cur),\r\n}\r\nconst env = [\r\n  baseProcedure\r\n]\r\n```\r\n\r\n**那么 let 绑定变量值意味着什么呢？**\r\n\r\n实际上 let 创造了一个新的环境，并将在该环境下对 body 部分进行求值。\r\n\r\n```javascript\r\nfunction letEval(exp, env) {\r\n  const value = exp.value\r\n  const frame = value.bindspecs.reduce((pre, cur) => {\r\n    pre[cur.value[0].value] = eval(cur.value[1], env)\r\n    return pre\r\n  },{})\r\n  // 处理另一种形式的 <LET> -> (let <VAR> <BINDSPEC> <BODY>) \r\n  // if (value.var) frame[value] = value.body\r\n  // 返回最后一个表达式的值\r\n  return value.body.value.map(e => eval(e, extEnv(frame, env))).pop()\r\n}\r\n```\r\n\r\n这就是我们对 let 表达式的解释，将 let 的 bind 取出来创建一个 frame 作为最内层环境插入 env，然后求值即可。<strong>……</strong>"
  },
  {
    "fileName": "用 JS 撸个 LISP 解释器（2）.md",
    "ID": 11,
    "Title": "用 JS 撸个 LISP 解释器（2）",
    "Tags": "编程 | 坑",
    "PublishDate": "2018/6/8 19:53",
    "Content": "\r\n\r\n\r\n接之前的坑，也许在真正开始写一个解释器之前，需要对解释器是什么做出解释才能继续。\r\n\r\n**解释器是什么？**\r\n\r\n解释器是一个在**特定上下文环境**中**求解表达式值**的过程。\r\n\r\n这个上下文环境包含原子符号和复杂符号，对表达式的求解过程就是将其逐步分解为原子符号的递归过程，这个过程就是 eval 函数，某种意义上 CPU 就是一个指令集的解释器。\r\n\r\n上篇中实现一个一个 tokenizer，并简单介绍了 Parser Combinator 的概念，接下来我将在此之上进一步用 Parser Combinator 实现 AST（抽象语法树） 的生成。\r\n\r\n```javascript\r\n// 一个高阶函数，用于创建标识符解析器， 比如说 Ｇ　-> s 解析 s 终结符\r\nconst ID = id => tokens => tokens[0] === id ? [{type: 'identifier', value: tokens[0]}, tokens.slice(1)] : null\r\n\r\n// 只要有一个解析器解析成功就是解析成功, 相当文法中的 | 符号，比如 G -> A | B | C\r\nconst OR = (...parsers) => tokens => {\r\n  for (const p of parsers) {\r\n    const result = p(tokens)\r\n    if (result) return result\r\n  }\r\n  return null\r\n}\r\n\r\n// 只有全部解析器都解析成功才成功， 相当于文法的连接\r\n// 比如对于文法 G -> A B C \r\n// 只有 A B C 都解析成功, G 才解析成功\r\nconst SEQ = (...parsers) => tokens => {\r\n  let result = []\r\n  let rest = tokens\r\n  for (const p of parsers) {\r\n    const r = p(rest)\r\n    if (r) {\r\n      result = result.concat(r[0])\r\n      rest = r[1]\r\n    } else return null\r\n  }\r\n  return [result, rest]\r\n}\r\n// 对 tokens 使用一个 parser 解析任意次，直到解析失败，将结果返回，max 设置为 -1 相当于正则里的 *\r\nconst REP = (parser, max = -1) => tokens => {\r\n  let count = 0;\r\n  let result = []\r\n  let rest = tokens\r\n  while(count >= max) {\r\n    const r = parser(rest)\r\n    if (r) { \r\n      result = result.concat(r[0])\r\n      rest = r[1]\r\n      count++\r\n    } else break\r\n  }\r\n  return [result, rest]\r\n}\r\n```\r\n\r\n和之前相比，我们的 parser 返回的不在是一个字符串，而是一个 AST 中的节点对象了，这里对象仅具备类型和值两个属性，如果有必要的话也可以机上行列号等内容为接下来语义分析过程提供更好的信息和报错提示。<strong>……</strong>"
  },
  {
    "fileName": "用 JS 撸个 LISP 解释器.md",
    "ID": 12,
    "Title": "用 JS 撸个 LISP 解释器",
    "PublishDate": "2018/6/3 21:45",
    "Tags": "编程 | JS | 坑",
    "Content": "\r\n一直想写个 LISP 解释器，为此啃 SICP、龙书、打印了 R5RS的规范文档，但是啃完这两本书实在太难了，咬牙坚持到了 SICP 四章，终于看到封面上那个 eval/ apply 循环的实现，这就是我入坑的动力啊，真要等到把书读完再去做，那估计这个愿望（坑）永远实现不了了，那就直接路撸起袖子上吧，哪怕做个玩具级别的。\r\n\r\n为什么这么执着 LISP 解释器呢？因为程序员三大浪漫啊！抛开浪漫不谈，看 eval / apply 循环这个图难道不觉得很 Cool 吗？ 有没有一种阴阳太极图的感觉，学起来真有一种学魔法的感觉。Cool~\r\n\r\n ![](https://camo.githubusercontent.com/0328cc5987e0ade0ba05d452171c90cbe4f61c43/687474703a2f2f67726f7570732e637361696c2e6d69742e6564752f6d61632f636c61737365732f362e3030312f6162656c736f6e2d737573736d616e2d6c656374757265732f77697a6172642e6a7067)\r\n\r\n\r\n\r\n事实上上实现一个 LISP 解释器并不难，为啥，因为这东西真的烂大街了，网上案例遍地都是，而且其语法足够简单，parser 起来不要太容易，并不需要你学会 DFA、NFA、LL，LR 这些分析算法才能做，直接强撸就是了，当然，会就更好了。\r\n\r\n不知道怎么动手？网上找不到好的案例？\r\n\r\n看这个Github 项目 [mal - Make a Lisp ](https://github.com/kanaka/mal)\r\n\r\n56 种语言 56 种 lisp 实现，还附赠编写指南 [The Make-A-Lisp Process](https://github.com/kanaka/mal/blob/master/process/guide.md)\r\n\r\n看不懂英文？这还有个翻译版的 [ The Make-A-Lisp Process 中文翻译 ](https://github.com/Windfarer/mal-zh#general-hints)\r\n\r\n当然，还有某个在扯淡的大佬文章 [怎么写一个解释器](http://www.yinwang.org/blog-cn/2012/08/01/interpreter)\r\n\r\n还有什么理由去拒绝尝试写一个 LISP 呢？\r\n\r\n那就开坑吧，在这之前知道一个编译器编译过程种的各个步骤就最好了，简单来说就是\r\n\r\n字符流 -> 词法分析 -> 符号流 ->语法分析 -> 抽象语法树(AST) -> 语义分析 -> 中间代码生成 -> 代码生成优化\r\n\r\n大概就这样，对于 LISP 解释器来说，知道怎么搞到 AST 就好，得益于 LISP 的语法简洁和同像性（代码和数据结构一致），这个不要太简单，LISP 源码差不多就是 AST 了。\r\n\r\n## 语法定义\r\n\r\n开始之前还是正经点，用 BNF 定义 LISP 的语法，LISP 的语法太简单了，我们先用 BNF 定义一个 LISP 前缀表达式语法的计算器，然后再一步一步扩展吧。<strong>……</strong>"
  },
  {
    "fileName": "用 CSS 实现网页追踪与分析.md",
    "ID": 13,
    "Title": "用 CSS 实现网页追踪与分析",
    "Tags": "前端",
    "PublishDate": "2018/1/20 22:15:05",
    "Content": "用 CSS 实现网页追踪与分析 ？ are you kidding me？ \r\n老实说刚看到 **[这篇文章](https://github.com/jbtronics/CrookedStyleSheets/blob/master/docs/README.zh.md)** 的时候我也有点吃惊，因为以前在的工作经历告诉我，要干这种事情得埋一堆 JS 代码，是一件苦差事。而用 CSS 来做确实是打破常规思维的想法，就像你从不会去想用面包当武器（然而确实有一种法式长棍面包风干后可以这么干），用 CSS 这样一门负责页面表现的语言去做追踪分析的事情着实要开很大脑洞了。\r\n\r\n考虑到页面分析追踪其实质是检测页面上某些状态及变化，然后报告给后端，这样一想，CSS 确实具备这样的能力，比如检测链接的点击的 `active` 选择器等等，这点能够想到，但是如何将状态变化报告给服务端呢？ emmm？ajax? CSS 显然不具备这种能力，但是它能加载资源，Bingo！\r\n简单来说就是通过一些特殊的选择器或者 CSS 的一些媒体查询等与语法还有 Hack 来判断状态，利用资源请求的跨域性向后端发信息。\r\n``` css\r\n#link2:active::after {\r\n  content: url('track.php?action=link2_clicked');\r\n}\r\n```\r\n没错，就是这样的脑洞，这里可以看到更多的 **[DEMO](http://crookedss.bplaced.net/)**!<strong>……</strong>"
  },
  {
    "fileName": "熵与人生.md",
    "ID": 14,
    "Title": "熵与人生",
    "Tags": "随想",
    "PublishDate": "2015/3/27 21:15",
    "Content": "熵，我一直以来将其当作一个物理学单位待之，事实上，从本质上而言，世界是遵守于物理定律的，生活，人，亦是这个世界的一部分。\r\n也许我应当庆幸自己能够知道这个概念，我察觉到了生活中那些导致我痛苦之事的根源，\r\n于我而言，令我苦恼之事显然来自于工作，无穷尽的工作，繁忙的工作，所有的这些工作于我而言真是困难的吗？  \r\n当然不是，这些事情并无多大挑战性，导致我苦恼的根源并非与事件本身，而是我在这无穷尽的事件中所感到的迷茫，事情多又掌控不过来，心便乱，苦恼随之而生。  \r\n说到底，于诸事之间，心不能安，此之为苦源。为何不能安？掌控不了，事件的发生和结束很大程度都不由你所掌控，试图去掌控这样的事情，显然是不可能的。  \r\n我曾看到各种各样的工作方法，时间管理方法，大抵可以归为两类，其一为自律，其二，都是在试图在不断流逝的时间洪流中去掌控自己，我们会将事情分而化之，分而治之，我们会按其轻重缓急列其次序，以上种种皆是让自己心安之法。<strong>……</strong>"
  },
  {
    "fileName": "滚动条导致计算值元素跳动的处理.md",
    "ID": 15,
    "Title": "滚动条导致计算值元素跳动的处理",
    "Tags": "前端 | 编码",
    "PublishDate": "2017/12/14 18:29:43",
    "Content": "\r\n博客的左侧栏用了百分比计算宽度，这样问题来了，页面的高度是不确定了，若出现滚动条则会导致页面宽度变化，然后侧边栏宽度就会跳动了，解决办法有两个：\r\n* 简单粗暴 `overflow-y: scroll;` 所有页面都显示滚动条，然后搞定，或者自己自定义滚动条接管。\r\n* 利用 CSS3 calc 属性 ` width: calc(100vw - 100%);`\r\n\r\n解释下，`100vw` 是浏览器内部宽度，也就是 `window.innnerWidth` 包括滚动条也计算在内，100% 是可用宽度是不计算滚动条的。\r\n    <strong>……</strong>"
  },
  {
    "fileName": "新的计划.md",
    "ID": 16,
    "Title": "新的计划",
    "Tags": "碎念",
    "PublishDate": "2018/1/20 17:19:52",
    "Content": "\r\n深圳回来后，从年初到现在一直都在忙碌着家里的各种事情，终于明白在深圳的时候妈妈每次视频通话都说“家里没事，不用你操心”这句话背后有多艰难了。上周四是母亲五十岁生日，为此刻意驱车回老家置办了酒席，邀请了那些我既陌生又熟悉的七大姑八大姨，自从读大学之后就许久未曾回过老家，亲戚们对我倒是印象深刻，可能是小时候特别皮吧，反而我自己好多都叫不出名字了，不过，最重要的是父母开心就好。\r\n\r\n父母的事情告一段落后，终于有闲考虑下自己今年的规划了，老家寒冷的天气着实容易让人提不起劲来，想到几乎每天都被被窝封印许久，年轻的时光就这样被挥霍还是很愧疚的。本来今年的唯一规划就是在家陪伴父母然后安心学习考研，对我而言，趁着年轻投入更多精力去学习或许是收益最大的选择。不过父亲恢复的状态让我这心又躁动了起来，父亲在愈后复健的活动上主观能动性惊人的强，不需要我和母亲的提醒，每天就自觉的按时去做各种恢复肢体运动的动作，即便丧失了大部分语言能力，在我给他装上认字的 APP 后也是每天跟着 APP 每天练习认字和发音，偶尔也能完整的清晰的说出一段话来，这样的状态也确实让我感到非常欣慰，抛开这些，父亲单位的省里领导又来慰问，这让我对某国企单位的好感倒是增加了不少。<strong>……</strong>"
  },
  {
    "fileName": "数据抽象.md",
    "ID": 17,
    "Title": "数据抽象",
    "Tags": "编码 | 哲思",
    "PublishDate": "2017/8/22 23:30:48",
    "Content": "\r\n> 现在到了数学抽象中最关键的一步：让我们忘记这些符号所表示的对象。（数学家）不应该在这里止步，有许多操作可以应用于这些符号，而根本不必考虑它们到底代表这什么。                                      \r\n————Hermann Weyl, 思维的数学方式\r\n\r\nSICP在我这似乎是一本永远读不完的书，一方面在于其难度，另一方面在于其不少的练习题，必须承认一点，可能确实是自己水平有限，每一道题对我而言都并不是那么容易的，几乎每道题都要经过仔细的思考才能做出来，面对这本书，我觉得更应当视其为一本数学书来对待，回忆下看数学教材时被其中的显然，易得等词汇爆掉脑袋然后怀疑人生的感觉吧，书中每一个知识点都有许多“小习题”等你来解决，但是，你真以为这些小习题能够轻松解决掉，那就太天真了，我曾经膝盖就中过一箭，这些小习题对我而言称之为时间黑洞也不为过，当然，或许真的有大神能把这些小习题快速刷掉吧，毕竟这个世界总是存在一些人能够如同数学教材作者那样，对“显然”，“易得”等这样的词汇有着相同感触。\r\n\r\n做这些习题是不容易的，若是不做的话，这本书恐怕也读不出什么意义来。正是这种不易所带来的挑战感促使着自己不断去完成这些练习，尽管它们并不能对工作或实际项目带来太多直接的收益，但是却能让自己更清楚编程本质是什么，对自己所做的，称之为“编程”的活动有一个更高视角。<strong>……</strong>"
  },
  {
    "fileName": "攀登抽象的阶梯.md",
    "ID": 18,
    "Title": "攀登抽象的阶梯",
    "Tags": "编码 | 哲思",
    "PublishDate": "2017/8/9 23:00:41",
    "Content": "\r\n![](http://imglf1.nosdn.127.net/img/UUcvQWZBZk9URHhUNmthQzQxSXpDVnhjaUsxSTloMW9ObXdwTHJ5RkJaZ2VuVUtVUUZJaVlnPT0.jpeg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\r\n常见的三种编程范式\r\n1. 命令式(过程式)\r\n2. 函数式\r\n3. 对象式\r\n\r\n命令式与函数式编程的主要区别体现在对过程提供的抽象能力上，在lisp中赋予了过程第一级权利:  \r\n1. 可以将过程命名  \r\n2. 可以提供给其它过程作为参数或作为返回结果\r\n3. 可以包含在数据结构中  \r\n\r\n第二点实现的代价就意味着将过程作为值返回，需要为过程中的变量提供存储环境，无论其是否被调用，如果采用词法作用域，那这就是闭包，在典型的命令式编程语言中，例如C语言，我们或许可以通过某些方式实现第一级权利，比如传递指针。  \r\n\r\n但是，两种编程范式的差异不仅体现在这一方面，还有对待副作用的态度，也就是赋值。\r\n在函数式编程中，函数的概念更贴近数学中映射的概念，输入参数，输出结果，简单的映射，将输入集映射到结果集，过程执行中不改变外部环境的状态，也不依赖外部环境的状态。由此引入了更多源自数学的概念，如高阶函数，偏函数，柯里化，函数组合等。  \r\n\r\n在命令式编程的典型C语言中，同样提供了对过程的抽象能力，即将过程抽象为函数，但是此函数就并非函数式编程语言里的函数了，最显然的是没有第一级特权。<strong>……</strong>"
  },
  {
    "fileName": "对自我的思考.md",
    "ID": 19,
    "Title": "对自我的思考",
    "Tags": "哲思",
    "PublishDate": "2017/8/6 17:52:40",
    "Content": "\r\n![](http://imglf1.nosdn.127.net/img/UUcvQWZBZk9URHhUNmthQzQxSXpDZkwveWhQWWFERy9mdXZCZUlnNm9UQ3k1ZHdNZUpLc3d3PT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\r\n生命是一个攀登阶梯的过程，很多人都以为这个阶梯只有一处，事实上却是有两处，一处登顶物质的巅峰，一处登顶精神的巅峰，一处通往外界的物质世界，一处通往内在的精神世界。  \r\n\r\n后者是孤独的，是少有人走的，并且随着物质世界的不断发展，选择后者的愈来愈少，更有甚者看不到这条路。通往内心的精神之路是孤独的，亦是困难的，为何而困难？因为它要求反求诸己，认识你自己。  \r\n\r\n认识并反省自己是第一个困难障碍，这涉及到一个重要的哲学问题，我是谁？  \r\n\r\n生命的无常往往使人迷失在脑海中无尽的念头中，往往错把那个脑海中的声音当做了所谓的我，我不开心，我想要，我要做，这些念头是我吗？若如此，那就后陷入无尽的追逐中去，这些念头是无常的，你永远无法把握住它的走向，往往仅是环境的波动，就会生出不同的念头来，被这样的无常牵引着，显然是不智的，你以为这样的念头是你自己，当你今天做出决定，明天行动时就会发现，昨天那个信誓旦旦做出决定的我呢？为何我没有了昨天那股热切的心情？为何我的计划无法实施？仿佛每时每刻的我都不是同一个人，我总是在当下之我与过去之我间徘徊与斗争，甚至不知下一刻之我又将会生出何种念想，于是焦虑产生了。我们常说的挑战自我，往往就是要反抗心中的那个声音做出行动。<strong>……</strong>"
  },
  {
    "fileName": "如何打印 Web 页面上指定区域的内容.md",
    "ID": 20,
    "Title": "如何打印 Web 页面上指定区域的内容",
    "Tags": "编码 | 前端",
    "PublishDate": "2017/12/11 13:24:52",
    "Content": "\r\n准备把简历挂到网上，万一被HR姐姐或者大佬看中呢？如果被看中的话如何方便他们打印你的简历呢？做过一堆电子流应用首先想到的就是弄个打印按钮，然后触发`window.print()`方法即可，但只是简单调用这个方法的话，打印的将会是整个页面的内容， 这显然不是想要的。\r\n\r\n于是稍加改动一下：\r\n```\r\ndocument.body.innerHTML = Element.innerHTML\r\nwindow.print()\r\n```\r\n这下可以了，打印的时候直接把想要打印区域的内容覆盖 Body 即可，但这样点击打印按钮后，整个页面的就会改变，而我只是单纯想打印而已，能不能更友好点？\r\n\r\n增加一个不占空间的 iframe 元素，然后触发打印的时候把要打印的内容塞进去即可。\r\n```\r\n<iframe id=\"printme\" src=\"\" width=\"0\" height=\"0\" frameborder=\"0\">\r\n</iframe>\r\n\r\nlet f = document.getElementById('printme')\r\n  f.contentDocument.write(Element.innerHTML)\r\n  f.contentDocument.close()\r\n  f.contentWindow.print()\r\n}\r\n```\r\n当然，如果有样式的话，也要把样式一同塞进去。\r\n    <strong>……</strong>"
  },
  {
    "fileName": "央视纪录片《极地》.md",
    "ID": 21,
    "Title": "央视纪录片《极地》",
    "Tags": "碎念",
    "PublishDate": "2018/1/22 21:56:11",
    "Content": "\r\n之前看过央视纪录片《第三极》，看完之后意犹未尽，没想到这会新出了这部**[《极地》](https://www.bilibili.com/video/av17956135/#page=2)**，又是一部截图可当桌面的纪录片，我曾今对那些说着去西藏净化心灵，洗涤灵魂的人嗤之以鼻，但是这部纪录片所描绘的人和景，让我对西藏一直抱有着某种虔诚的信仰，那里，对我而言，或许是需要以朝圣的心态前往的地方吧。\r\n\r\n作为一个工作之余有着摄影小爱好的人来说，央视一部又一部高水准的纪录片刷新了我对祖国地理的认知，让我从风景外国独好转向了祖国的西部，心中的远方也因此而变得更近一些了，有两个地方是我最想去的，一个是新疆，一个是西藏。\r\n\r\n也许是因为距离，或者是时间的缘故，我一直没能安排去那的计划，这两个地方并不是你节假日之余乘坐飞机或者高铁就能玩尽兴的，就以西藏而言，最美的风景都在路上，在那条被称之为中国人的景观大道上，国道318。而从成都驱车出发沿 318 去西藏至少需要九天，显然，若是在职的话利用国庆时间肯定是要请假的，这里只考虑时间，然后再看看新疆，从深圳或者中国东部出发乘飞机去新疆乌鲁木齐，需要飞行五个小时左右，然后再看看从乌鲁木齐去赛里木湖、去喀纳斯、去喀什的距离，这些景点之间的距离动不动就几百公里，从喀什飞往上海的距离足够从喀什飞亚欧交接的伊斯坦布尔了，我本以为很多风景得去欧洲，然而《航拍中国》彻底颠覆了我对新疆戈壁沙漠的映像，地理书上说中国拥有世界上最丰富的地貌，这话我算是有感觉了。\r\n\r\n16年十一的时候围绕川西游玩了一圈，尽管没能去到西藏，但也算是感受过了藏区的风景，川西还有许多地方值得去，但愿以后还能再去吧。<strong>……</strong>"
  },
  {
    "fileName": "国庆云南游记.md",
    "ID": 22,
    "Title": "国庆云南游记",
    "Tags": "碎念",
    "PublishDate": "2017/10/15 19:17",
    "Content": "![](https://wx1.sinaimg.cn/large/007113CZgy1fm9iws2v65j318w0u0qeq.jpg)\r\n双脚踏足地狱，而眼睛放在天堂，雨崩，云南最后一片未被开发的处女地，从半专业徒步跨入专业徒步的必经之旅。\r\n本来国庆计划去雨崩徒步，为此特地请了三天假，加上中秋国庆一起足足11天，然而最终还是因为时间关系未能踏足“天堂”，看了微信里朋友发的照片时，更是觉得可惜，雨崩也成了我云南之旅最大的遗憾了。\r\n这是一场计划好的旅行，而我也并未抱着旅游的心态，因此在装备准备上也是以轻便为主，虽然落下遗憾，但是总体来说也是不虚此行吧。抱着何种心态去一个地方所带来的感受是截然不同的，此行既是旅行，那便做好了面对挑战的准备，途中所经历的一切未知对我而言都是收获，不论其带来的感受是艰苦亦或者快乐。\r\n![](https://wx1.sinaimg.cn/large/007113CZgy1fm9iwm385qj318w0u0wpm.jpg)\r\n谈到大理，第一个想到的词就是“风花雪月”， 也确实如此，在大理的街道边，古城里，这个词总是时不时闯入眼中，而我的大理之行，感受最不深的恰恰却是这个词,而是一种被微风包裹的惬意与悠闲，仿如沉入美梦，忘了忧愁。<strong>……</strong>"
  },
  {
    "fileName": "又一篇什么是Monad.md",
    "ID": 23,
    "Title": "又一篇什么是Monad",
    "Tags": "编码",
    "PublishDate": "2017/9/1 21:48:38",
    "Content": "\r\n一开始抱着猎奇的心态学习各种编程语言，从汇编、C/C++、Python、直到LISP。工作后才幡然醒悟，学这么多编程语言而不去使用，那无异于“以有涯随无涯”，最后回首才发现遗忘是多么可怕的事情，学了这么多编程语言到如今也几乎忘得差不多了。当然，并不能因为遗忘而否定学习的意义，学习的意义正是那些遗忘之后留下的东西，学过这么多编程语言，了解了这么多编程范式，学起新的语言来也确实颇有一番一通百通的感觉，拿起文档就写，新语言的特性也能很快上手。真正停止追逐语言的脚步，是从SICP开始的，像是受到了启示，学语言这么久，感触最深的一点，那就是对于学习者而言，需要的不是一本规范，也不是一本操作手册，而是一本解释，SCIP正好回答了我的疑惑，正如其书名所言，讲的是计算机程序的构造与解释，理解到编程活动的本质是通过抽象手段控制复杂度这样道理后，对语言也就没有了追求，转而关注各类语言中所提供的“抽象方式”，对某门语言的学习，仅仅是学习如何在其中恰当的表达思想，不再去死扣规范和各种细节，当然，如果这门语言是工作用的，那才值得这样做。\r\n\r\n当见识到抽象的力量之后就一发不可收拾，在函数式编程里充斥着各种“黑魔法”，而自己工作用的JS语言恰好具备展示这些“黑魔法”的能力，尽管有些蹩脚，但也并非不能用，平日里经常用JS写一些函数式的代码，作为一个“魔法师”，总会对自己的能力和知识感到不满，便求精进，然后就理所当然的掉进了函数式的坑里，撞死在范畴论和Monad面前。<strong>……</strong>"
  },
  {
    "fileName": "博弈论带来的启示-信任的进化.md",
    "ID": 24,
    "Title": "博弈论带来的启示-信任的进化",
    "Tags": "随想",
    "PublishDate": "2017/12/15 00:04:47",
    "Content": "\r\n朋友向我推荐了这个游戏**[《信任的进化》](https://www.sekai.co/trust/)**，最早在 V2EX 上就有看到过，但是因为翻译的缘故没有认真玩，这次认真玩过之后得到了不少启示。\r\n\r\n在持续性的重复活动中，若该活动能够产生非零和的收益，那么选择相互彼此信任是最好的策略，简单来说就是双赢。在这里，我相信整个世界大多数创造性的活动都应该是创造价值的，彼此间的信任将能放大这种收益，但是是否能彼此建立信任的基础却和这个他们对这个人性的看法有关，即持有性善论还是性恶论或者是中立。\r\n\r\n信任建立的关键在于第一步，即是否相信对方？能否提供一次信任的机会？\r\n如果对方是并非欺诈者，那么信任将会快速建立起来，并且彼此将会愈加越宽容。同样的，首次选择善意也能将中立方转化，对于欺诈者，你最多也就损失一次善意，并将彻底杜绝后续的恶意。<strong>……</strong>"
  },
  {
    "fileName": "博客文章获取接口修改.md",
    "ID": 25,
    "Title": "博客文章获取接口修改",
    "Tags": "编码",
    "PublishDate": "2017/7/25 22:43:00",
    "Content": "\r\n改成从项目源码中读取md文件，GitHub的接口调用有限制，如果不用access_token调用的话是有60次/每小时的调用次数的，用token则有5000次/每小时，这对博客来说是够用了。  \r\n因此，可以申请一个只读权限的token，但是token如果直接写在源码内并上传至GitHub仓库，则会被GitHub的安全机制检查出来，申请的token就会被被删除（GitHub为了避免程序员误传Token真时操碎心 - -|||），但是，在源码内简单掩饰下可以绕过这个检查了，这样玩的话，就要注意申请的Token权限范围。\r\n    <strong>……</strong>"
  },
  {
    "fileName": "博客搬家.md",
    "ID": 26,
    "Title": "博客搬家",
    "Tags": "编码",
    "PublishDate": "2017/10/28",
    "Content": "\r\n阿里云(套路云)的客服打电话给我说他们双十一活动，服务器打折，于是活动期间没能忍住手买了 1C1G 的丐版服务器，选了香港区，想着再怎么吃灰也能当个梯子嘛，果然，这手真是忍不住的。\r\n吭哧吭哧把博客挪到云服务器上后，第一时间干掉了 coding.net 的页脚，然后用 acme.sh 申请了 Let’s Encrypt 的证书，证书到期自动更新，看到域名旁边的小绿锁，完美！\r\n趁着机会又复习了下nginx的配置，既然都上了服务器了，后续就可以考虑不用静态博客了,笑~\r\n正巧最近学习 Golang ，准备自己手撸一个微服务框架，已经把框架的 Router 撸出来了，这坑又不知道什么时候能填完。\r\n然后... 是不是前端也要换换呢？ 最近 Vue 2.5 提供更好的 TypeScript 支持，于是突然又有了一个大胆的想法，乘机会玩玩吧，现在博客速度太慢了，主要是静态资源这块需要优化，考虑薅各大 CDN 的免费流量试试~\r\n    <strong>……</strong>"
  },
  {
    "fileName": "前端监控.md",
    "ID": 27,
    "Title": "前端监控",
    "Tags": "前端",
    "PublishDate": "2018/7/10 18:09:14",
    "Content": "\r\n## 背景\r\n\r\n最近项目痛点，就是应用在我们的设备上好好的，怎么一到用户那就反馈各种问题呢？这个痛点相信不止我一个人遇到，甩给测试去控制那也不容易啊，如果公司穷，测试设备覆盖不全就更痛苦了，而且用户对问题无法给出技术性的描述，作为开发只能靠经验推断，心累。\r\n\r\n于是最近几天我就研究了下**前端监控**相关的内容，写了个简单的信息采集工具，当然，业界已经有许多现成的方案了，如 funDebug、bugsnag、BadJS、betterjs 等，但我就是想自己造一个轮子！\r\n\r\n好像代码量不多？我上我也行（错觉），自己造一个学习下（最重要的理由）。\r\n\r\nGitHub 链接：[fe-monitor](https://github.com/lzcers/femonitor/tree/master/src)\r\n\r\n## 设计要求\r\n\r\n- 易于扩展，可自定义\r\n\r\n  我哪天想到啥新的监控点可以直接扩展，比如说不仅仅是性能监控，js 错误监控之类的，订单请求也可纳入监控范围啊，不是偶尔掉单吗？前端也可以抓点数据嘛。还有用户行为路径之类的数据。\r\n\r\n- 无侵入，小侵入\r\n\r\n  最好简单引入个 sdk 就行，尽可能不要埋点\r\n\r\n- 适用不同框架\r\n\r\n  比如连接 Vue.config.errorHandle \r\n\r\n## 模块\r\n\r\n- 信息采集\r\n- 信息上报 \r\n- 信息分析\r\n- 报警\r\n- 信息可视化\r\n\r\n在前端主要做的就是信息采集和信息上报，数据到了后端存储后再做信息分析，报警，可视化之类的工作，那么问题来了，首先要确定是到底要**采集哪些数据**？采用什么**上报策略**？所有数据一律上报显然不现实，没那必要，也没那么大存储空间。<strong>……</strong>"
  },
  {
    "fileName": "利用 serviceWorker 快速把网站变成 PWA 应用.md",
    "ID": 28,
    "Title": "利用 serviceWorker 快速把网站变成 PWA 应用",
    "Tags": "前端 | 编程",
    "PublishDate": "2017/12/17 20:16:06",
    "Content": "\r\n## 什么是 PWA ？\r\nPWA（Progressive Web Apps）是 Google 提出的用前沿的 Web 技术为网页提供 App 般使用体验的一系列方案。\r\n\r\n## 它是如何做到的？\r\nPWA 主要利用了 service Worker 和 caches API，通过两项技术就可以将 Web App 的所有请求劫持并缓存下来，你可以自由的编写策略去决定是否从后端加载数据，相比原生 App 更新后每次都要重新打包，这就更“一颗赛艇”了。再部署了 Service Worker 后，只需要再配置 manifest.json 文件即可，该文件描述了应用被安装后的图标已经应用名等信息。\r\n```\r\n<link rel=\"manifest\" href=\"/static/manifest.json\">\r\n```\r\n在支持 PWA 的浏览器上，打开页面时会提示是否将该页面安装至桌面，安装后，就能获得和原生 App 近乎一直的体验了，关于 PWA 的支持度可以看[**这里**](https://ispwaready.toxicjohann.com/?from=groupmessage)。\r\n\r\n## 如何快速部署？\r\n#### Service Worker\r\n显然，自己写 Service Worker 和缓存策略逻辑有点麻烦，简单点，我们通过 Webpack 的 sw-precache-webpack-plugin 插件来自动添加 Service Worker，并配置缓存策略，具体配置参考[**这里**](https://github.com/goldhand/sw-precache-webpack-plugin)。<strong>……</strong>"
  },
  {
    "fileName": "写作是一个学习过程.md",
    "ID": 29,
    "Title": "写作是一个学习过程",
    "Tags": "碎念",
    "PublishDate": "2018/3/6 00:59:23",
    "Content": "\r\n旅行的意义不在于终点，而是走过的路。\r\n\r\n文章不是目的，写作过程中的思考才是，多数时候我将写作当作一件梳理思考的方法，将思想的过程书写下来，与其说是在写文章，倒不如说是在做记录以方便自己回溯。作为书写者，日后从自己记录的内容中能还原思考的路径是容易的，但他人就未必了，因此也从未考虑过写的东西与他人看。\r\n但书写的时候假设读者的存在是有意义，而且考虑的读者层次越低越好，如果未曾考虑过读者的写作仅是记录和梳理思考，那么考虑读者的写作就意味还需要做某种程度的解释，有一个学习的著名方法叫做费曼方法。\r\n```\r\n费曼技巧有四个简单的步骤：\r\n1. 选择一个概念\r\n2. 把它教给完全不懂的另外一个人\r\n3. 如果卡壳，回到原始材料\r\n4. 回顾后简化语言表达（可选择）\r\n```\r\n通常情况下我们难以找到一个合适的倾听者，但这个方法的核心是表达，因而用语言也好，文字也罢，效果应该是相同的，再考虑方法的第二个步骤，”教给一个完全不懂得另外一个人“，我们可以将文章读者的预设为外行人，这样一来，整个方法都可以用写作来实践，因此，写作即是学习。<strong>……</strong>"
  },
  {
    "fileName": "写一个简单的 Markdown 编辑器.md",
    "ID": 30,
    "Title": "写一个简单的 Markdown 编辑器",
    "Tags": "编码",
    "PublishDate": "2017/12/7 00:28:49",
    "Content": "\r\n### 准备工作\r\n首先，我们要有一个敲文档的框框，就你了`<textarea>` 标签！\r\n现在我们有了一个框框，然后我们需要 Duang 的一下把框框里的 MD 标记文本编译成 HTML 标签，如果能带上漂亮的样式就更好了，能支持 yaml 写点元数据就完美了，再多提点要求，能不能根据标题生成目录呢？\r\n\r\n起手式准备好之后，首先解决第一个问题，把 MD 标记语法转 HTML 怎么整？ 前辈们告诉我们不要自己造轮子那是因为他们已经造过了，所以果断祭出 GitHub ，面向 GitHub 编程，于是我们找到了 **[marked.js](https://github.com/chjj/marked)** 。\r\n\r\nMarked.JS ：\r\n> A full-featured markdown parser and compiler, written in JavaScript. Built for speed.\r\n\r\n这是一个 markdown 的解析编译器，你可以直接拿到编译后的 HTML 文本，最重要的是这个轮子提供了介入编译过程的接口，你也可以拿到解析后的 Tokens 自己搞些小动作。\r\n\r\n### 变漂亮点\r\n经过 marked.js 解析后，我们拿到了编译后的 HTML 文本，直接用当然可以，但是不够漂亮啊！所以聪明的你可以自己写些样式了，啥？ 想偷懒？当然，我们肯定有轮子的，依旧祭出神器，我就用了性冷淡的 **[github-markdown-css](https://github.com/sindresorhus/github-markdown-css)**，当然，还有更多选择。\r\n### 搞点事情\r\n#### 支持 YAML 写入元数据\r\n同 Markdown 语法解析一样，YAML 同样也需要相应的解析器，这种轮子自己造是不明智的，硬要做那也没办法了，这里我们使用 **[js-yaml](https://github.com/nodeca/js-yaml)** 。\r\n直接上码：\r\n```typescript\r\n// 添加元数据支持\r\nfunction splitInput(str: string) {\r\n\tif (str.slice(0, 3) !== '---') return\r\n\tlet matcher = /\\n(\\.{3}|-{3})/g\r\n\tlet metaEnd = matcher.exec(str)\r\n\treturn metaEnd && [str.slice(0, metaEnd.index), str.slice(matcher.lastIndex)]\r\n}\r\nconst mySplitInput = splitInput(src)\r\nconst markdown = mySplitInput ?  mySplitInput[1] : src\r\nconst meta = mySplitInput ? yaml.safeLoad(mySplitInput[0]) : null\r\n```\r\n简单利用正则把 --- 或 ... 开头结尾的内容抓出来，然后丢给 js-yaml，打完收工搞定，要怎么利用就自己看着办吧，除去这部分的内容，剩下的交给 marked.js 处理。<strong>……</strong>"
  },
  {
    "fileName": "关于沟通.md",
    "ID": 31,
    "Title": "关于沟通",
    "Tags": "随想",
    "PublishDate": "2015/9/18 22:29",
    "Content": "思考和表达这两种能力并非正相关的，也许你的思考能够达到很深的程度，\r\n但是这并不意味着你能将如此深奥的思考表达出来。\r\n\r\n当我们对某个对象展开思考或者表达时，对于思考而言，我们思考的对象将会随着思考的深度逐渐变得复杂抽象起来，但表达却是另外一个过程，我们需要将表达的对象变得形象，简单，明确起来\r\n\r\n这是两种截然相反的过程，思考时将对象变复杂抽象，而表达确实将思考变得简单形象。\r\n\r\n与思考不同的还有一点就是，思考是为了让自己理解，而表达却是为了让他人理解。\r\n\r\n你想的是A ,说出来的却是B， 别人听到以为C，然后事实却是Ｄ\r\n这样的情况是经常发生的。\r\n\r\n人之患，在好为人师，无论如何，保持谦虚总是一种必要心态，\r\n错误往往是因为过度自信所导致的，而非小心谨慎。<strong>……</strong>"
  },
  {
    "fileName": "关于并发的理解.md",
    "ID": 32,
    "Title": "关于并发的理解",
    "Tags": "编程",
    "PublishDate": "2018/3/4 13:41:37",
    "Content": "\r\n在在考虑并发编程中，首先要思考的是时间是什么？ 我们可以简单的将时间看作是施加在所有事件上的顺序。在纯粹的函数式编程中，不论对表达式采用何种求值顺序，应用序，正则序也好，都不会影响最终的求值结果，只是中间过程会有所差别，在这样的编程模型中，我们似乎可以忽略时间施加在事件上的顺序，因此，函数式程序可以进行自动的并行化，没有赋值和可变量，意味着引用透明，即外延相等的函数可以相互替换，如果两个函数对于所有参数产生的结果都是一样的，那么它们就是相等的，可以相互替换的（将函数的结果缓存以加快速度，正是这一思想的诠释）。\r\n\r\n改变从赋值的引入开始，在这之前，求值使用代换模型，如同处理数学函数一样，这个模型并不能处理赋值的场景，因此需要使用更为复杂的环境模型，在这个模型下，考虑并发编程就会带来前所未有的复杂和挑战。当然，有一个概念是始终需要明晰的，那就是关于并发和并行的区别，最简单的理解，并发是同一时间应对多件事情的能力，而并行是同一时间处理多件事情的能力。对于相互较为独立的多个事件而言，我们要想在同一时间应对，那么最好的办法就并行化，将任务分发到不同的处理单元上去。<strong>……</strong>"
  },
  {
    "fileName": "关于可视化页面构建工具的思考.md",
    "ID": 33,
    "Title": "关于可视化页面构建工具的思考",
    "Tags": "编程 | 前端 | 随想",
    "PublishDate": "2018/06/05 21:30",
    "Content": "\r\n\r\n\r\n## 引言\r\n\r\n现代化的企业管理离不开 IT 系统的支撑，而随着业务和人员的扩张，对 IT 系统及 IT 工具的需求也是日益增长的。\r\n\r\n当公司扩张到一定程度时，公司的运作就不能完全依托于人，若是将公司类比于机器，那么要想这部机器能够正常运转，甚至高效运转，那就必须制定合理有效的流程，并研发 IT 系统去承载。\r\n\r\n起初我们做事会沉淀一些优秀的实践，随着这些优秀实践的扩散，就会想到将其规范化、标准化、进一步的甚至转换成流程，再将流程用 IT 系统承载使其自动化。\r\n\r\n这样就会有很多管理信息系统的开发需求、工具开发需求等，来自业务方的需求尽管很多，但大致都是可以归类的，其主要的差异仅仅是因为业务场景的特殊化，从而需要 IT 工具或系统做一些定制化的开发，甚至新做一个。\r\n\r\n这样的成本对公司而言显然是不可接受的，对于程序员来说，重复类似的工作也极易丧失工作动力，那么理所当然的想到如何从这样的重复中脱离出来，而其解决方案就是**可视化页面构建器**，这样的工具相信在不少公司都存在，有用来做活动促销页面的，有用来做中后台管理系统的，有用来做报表的，甚至其它行业的都有，等等。<strong>……</strong>"
  },
  {
    "fileName": "使用 Systemd 设置 Linux 应用自启动.md",
    "ID": 34,
    "Title": "使用 Systemd 设置 Linux 应用自启动",
    "Tags": "编码 | Linux",
    "PublishDate": "2017/12/11 17:27:03",
    "Content": "博客有时候莫名其妙挂掉，看后台访问日志发现一堆类似 /myphpadmin 的路径请求，想来是批量扫描漏洞抓肉鸡的吧，我这小站纯当树洞和 Wiki 使用，价值又不大，随便攻击咯。只是每次重启服务器得把后端服务跑起来有点麻烦，于是稍微学习了下 Linux 下设置应用自启动的方法。\r\n\r\n**有几种方法实现目的**\r\n1. 配置 /etc/rc.d/rc.local 脚本 ，该脚本在引导过程的最后一步被执行\r\n2. 添加脚本至 /etc/rc.d/init.d 子目录，适用于需要细致控制的启动需求\r\n3. 设置 crontab 任务计划服务\r\n4. 使用 systemd 注册服务\r\n\r\n## 关于 Systemd\r\n这是现代 Linux 发行版中的显著变化之一，或许也是最颇具争议的变化。 Systemd 是 Linux 内核启动的第一个程序，并且扮演多种角色，比如启动系统服务，处理登录，定时执行一些任务，其重要性不言而喻，并逐渐成为 Linux 的基础组件的一部分。\r\n\r\n如何通过 Systemd 来注册一个服务呢？举个栗子\r\n```\r\n# /lib/systemd/system/supervisord.service\r\n[Unit]\r\nDescription=Process Monitoring and Control Daemon\r\nAfter=rc-local.service\r\n\r\n[Service]\r\nType=forking\r\nExecStart=/usr/bin/supervisord -c /etc/supervisord/supervisord.conf\r\nSysVStartPriority=99\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n```\r\n这是一个开机自动启动 supervisord 的服务配置，嗯，就是博客 Go 后端的守护进程。<strong>……</strong>"
  },
  {
    "fileName": "从静态博客转到Golang + MongoDB后端.md",
    "ID": 35,
    "Title": "从静态博客转到Golang + MongoDB后端",
    "Tags": "编码",
    "PublishDate": "2017/11/29 23:39:47",
    "Content": "\r\n因为最近在学 Golang 的缘故，所以顺手就将博客从静态博客改成了 Golang + MongoDB 后端。  \r\nGolang 这门语言初看像是 C 语言的加强版，有 C 语言开发经验的话能够很快上手，以现代编程语言的视角来看，Golang 实在是简洁得有些过分了，少了很多时髦的语法特性，对泛型的支持也经常被人拿出来鞭尸吐槽，但是真正使用下来确实给人一股小清新的感觉，缺失的那些时髦特性并没有给实际开发带来很大麻烦，Golang 简洁实用的官方库带来了非常大的助力，特别是对于网络编程，加上原生对并发的支持，足以弥补很多语法特性缺失的遗憾了。\r\n\r\n总结来说，写的很爽，可以推荐给朋友，用《七周七语言》的话来说，如果学一门新的编程语言不能改变你的编程思想，那就不值得学，恰好，Golang 确实是一门能够改变你编程思想的语言，基于 CSP 的并发模型加上语法级的并发支持，能够让你自由畅快的用并发的思想去构建程序，如果之前缺乏编发编程方面的实践，那 Golang 确实值得投入时间去学习一番。\r\n    <strong>……</strong>"
  },
  {
    "fileName": "从浏览器工作机制看性能优化.md",
    "ID": 36,
    "Title": "从浏览器工作机制看性能优化",
    "PublishDate": "2018/7/9 15:31",
    "Tags": "前端",
    "Content": "\r\n## 背景\r\n\r\n之前学习前端过程中做了不少关于性能优化的笔记，但是大多都太零散，无法串联起来，便想写一篇文章将所有知识点串起来，从浏览器的关键渲染路径来看性能优化是非常适合的，当然，前端的性能优化也不仅仅是这些，还有一些后端的优化工作也是非常有效的，决定页面用户体验不仅仅是前端，还有后端的协同工作。\r\n\r\n## 浏览器渲染过程\r\n\r\n### URL 解析\r\n\r\n1. 用户输入 URL\r\n\r\n2. 从URL 中解析出主机名\r\n\r\n3. DNS 查询解析出主机名对应的服务器 IP\r\n\r\n   先查本地 DNS 缓存记录 （比如 hosts 文件），没有再向 DNS 服务器查询，并将结果缓存\r\n\r\n4. 根据 URL 提供的端口号（默认 80）请求服务器获取静态资源\r\n\r\n   经过三次握手建立 TCP 连接，然后开始传输 HTTP 报文 （Request，Response），HTTP 协议是应用层协议，建立在 TCP/IP 协议上。\r\n\r\n5. 关闭连接，浏览器开始解析文档\r\n\r\n6. 如果文档中涉及其他资源则重复以上动作，直至所有资源加载完毕\r\n\r\n### 页面渲染\r\n\r\n![](..\\imgs\\browserRender.webp)\r\n\r\n1. 处理 HTML 标记并构建 DOM 树。\r\n\r\n   深度优先遍历过程，默认遇到 script 回解析执行其中的脚本，并堵塞渲染。（加上 defer,  async 属性可以控制执行 javaScript 的执行时间）\r\n\r\n2. 处理 CSS 标记并构建 CSSOM 树。<strong>……</strong>"
  },
  {
    "fileName": "书写以及文字.md",
    "ID": 37,
    "Title": "书写以及文字",
    "Tags": "随想",
    "PublishDate": "2015/1/31 23:06",
    "Content": "人的大部分生命体验是受限于当下的，一切感官所带来的体验都将被时间禁锢于当下，当下即逝，无常处处皆是，即便我们的意识也是如此，虽然我们可以靠着记忆短暂的回溯过去的体验以及思考，但是，大脑并非总是可靠的，即便借助于非凡的记忆，你能记住所有的一切，但是依旧被自身以及时间所限制，你无法将你的体验你的思考跨越时间传递于它人，这是靠语言言传身教所不能做到的。  \r\n文字以及书写的意义就在于此，我们可以将自己的体验，思想寄托于文字，载于书本亦或者其它载体上，相较于人短暂的一身，这些载体却是可以穿越很长一段时空的事物，甚至可以轻易复制，一代，一代流传至永远。  \r\n对于个人而言，书写也许并非为了传递思想，最重要的是回溯自己，你的思考，你的体验，你的一切，都可以化作文字，对于记忆并非出众的我而言，这毫无疑问是最好的恩赐了。  \r\n文字所载的文章变化，忠实的记录着人的改变，从过去的自己中吸取经验，创造更好的未来，将思想一遍一遍洗筛，如同淘金一般，凝结出最深刻的洞见。\r\n    <strong>……</strong>"
  },
  {
    "fileName": "不求甚解与刨根问底.md",
    "ID": 38,
    "Title": "不求甚解与刨根问底",
    "Tags": "随想",
    "PublishDate": "2017/9/5 23:28",
    "Content": "\r\n怀疑自己有强迫症，遇到不能理解的问题总是钻牛角尖似的想弄明白，很随意地就能扑在一个问题上耗个几天，有些时候也佩服自己的执着，特别是当一个问题经过冥思苦想最终念头通达的时候，那就像卸下包袱瞬间得到释放和自由的感觉，刷算法题就经常如此。  \r\n\r\n但是，能够念头通达的好运不是时常都有的，总会有那么些问题会像堡垒一样立在你面前，怎么都攻克不了，凭时间去一点一点磨也做不到，这个时候就会感到焦虑和绝望了，这若是智商的天花板，那就更绝望了。对此我更相信，之所以不能解决，并非源自智商，而是缺乏足够的信息，这些信息是经验、知识、实例。刨根问底是好的，如果能够清楚的知道自己到底在哪碰壁，是哪一点不能理解，那么在时间充裕的情况下是可以继续刨下去，但是如果你没法获得足够的信息，甚至不理解自己为何不能理解，那就要适可而止了。  \r\n\r\n我认同刨根问底的精神，但有时候也应当不求甚解，在有限时间内的学习，不能将大量的时间耗在这种刨根问底的行为上，有些东西总是需要有足够的例子去支撑才能理解的，最好是分阶段来，第一阶段不求甚解大量积累案例和知识，再逐步深入细化刨根问底，一开始就想着彻底理解一个东西，那既困难又不现实，反而使自己焦虑，徒增烦恼。<strong>……</strong>"
  },
  {
    "fileName": "不念过去，不畏将来，珍惜现在，再见 2017.md",
    "ID": 39,
    "Title": "不念过去，不畏将来，珍惜现在，再见 2017",
    "Tags": "碎念",
    "PublishDate": "2017/12/31 17:02:01",
    "Content": "\r\n2017 年，我很懵。\r\n上半年追逐爱情失利，下半年又接着父亲中风，年底圣诞夜大娘去世，直到现在敲下这些字时也依旧感到缺乏真实感，整个人都是懵的，倘若真是梦该多好啊。\r\n\r\n这一年发生太多事情了，原本行动自如身体硬朗的父亲因病变得行动不便，语言能力丧失，最亲近的大娘也因病去世，而我也结束了自己在深圳打拼的计划。未来彻底陷入了迷茫，我本以为自己的人生基调应该早已注定，努力工作攒钱，然后成家立业，然后教育子女，然后在夕阳下听着音乐休憩。\r\n\r\n生活似乎厌恶平静无澜，因而给了我一阵飓风。<strong>……</strong>"
  },
  {
    "fileName": "七夕.md",
    "ID": 40,
    "Title": "七夕",
    "Tags": "碎念",
    "PublishDate": "2017/8/29 21:59:29",
    "Content": "\r\n毫无悬念，这个日子对我而言依旧没有意义，不过倒也过得意外的充实，好死不死的科目二考试约在了8月29日，理所当然，考前当然要好好突击训练一番咯，为此特地请假两天，领导吐槽说，这考试代价真高啊，考试的调休是用双倍工资的钱换来的，当天模拟考试一个半小时就是400块钱花费，如此代价之下不过简直对不起这投入啊。\r\n\r\n考前一天，早上七点半就赶往驾校，平时上班也没这么早啊，泪~~，比早起更可怕的是台风，今年深圳真是神奇了，天鸽刚过不到一周，又迎来今年第14号台风“卡帕”，真是可怕，不得不冒着暴雨练习，在此已经做好了明天雨中考试的准备，好在幸运眷顾，考试当天放晴，艳阳高照，也许我昨天看的是假的天气预报吧，考试的第一把直接挂在左倒库，倒车不入，差点心态爆炸，想着没有压线，位置准的一比，这把肯定稳，结果因为座椅没调给挂了，第二把就随意了，大不了就下月再考呗，结果第二把险过。所以说，科目二考试的不光是技巧和熟练度，还考心理素质啊，回想下平时训练，无非就是那几个套路，对那几个点。  \r\n幸运貌似只眷顾了我？同行三人考试就我一个过了，汗(⊙﹏⊙)b，祝福每天和我一起练车的妹子，辛苦了，感谢~，反正她看不到。^_^  \r\n报名的时候和同事一同报名，想着能一起考，结果两个女同事率先完成了科目二考试，快的都已经考科目三了。<strong>……</strong>"
  },
  {
    "fileName": "《逻辑的引擎》读后感.md",
    "ID": 41,
    "Title": "《逻辑的引擎》读后感",
    "Tags": "碎念 | 读书",
    "PublishDate": "2018/2/26 00:56:10",
    "Content": "\r\n>  计算机是数学家一次失败思考的产物。   ——无名氏\r\n\r\n从一篇博文上又看到了《逻辑的引擎》这本书的推荐，于是找来电子书连夜看完，看完后，对于计算机的存在又再次感到震撼，尽管曾读过《编码》、《深入理解计算机系统》之类的书，对计算机的组成也有一点了解，也许对于正在使用的这台机器而言，它称得上是制造业的奇迹，数以亿计的晶体管凝聚的造物，但是它又何尝不是人类心智的荣耀在现世的具现呢。\r\n\r\n计算机的诞生是一场历经三个世纪的征程，一切从莱布里茨之梦开始。\r\n\r\n首先考察我们理性的根基，当我们在思考中所称的逻辑推理是什么？他与计算有什么区别？二者似乎是一个硬币的两面，逻辑推理的过程可以通过布尔代数等代数体系的计算来表达，而数学计算又可以被描述成一个数理逻辑的的推理过程，莱布里茨之梦就是这样一个想法，找到一个描述人类普遍概念的符号系统以及操作这些符号的规则，从而可以将现实问题用这套符号系统表达，利用这些符号的规则进行推理或者称之为计算，以此来得到问题的答案。显然，这种过程是机械的，因此我们可以为其创造一台机器来执行这个过程。<strong>……</strong>"
  },
  {
    "fileName": "《寻梦环游记》观后感 - 终极的死亡.md",
    "ID": 42,
    "Title": "《寻梦环游记》观后感 - 终极的死亡",
    "Tags": "碎念",
    "PublishDate": "2017/12/6 20:40:50",
    "Content": "\r\n看到朋友圈都在推荐这部片子，评分高的惊人，我本不是喜欢追电影的人，除非有约我很少去看电影，之前因为某种原因特意办了附近电影院的会员卡，现在卡上还有些余额，想来以后估计也没机会用了，加上离职时间有闲，便买了电影票。\r\n一个人看电影的体验说不上好，若是电影厅人多的时候，两边皆是情侣的话，那对我可能就是折磨了，所以难得一个人去看场电影就选了一个冷门的时间段，下午两点又非周末，这个时间都在上班，想来除了自己应该也没多少人能选这个任性的时段了吧，不出所料，进 ZMAX 厅之后，偌大一空间就后排远处有一对，几近包场的体验，也算运气不错。\r\n电影有些出乎意料，虽说讲小孩追逐音乐梦想的过程，但揭示的却是亲情的重要性，电影是外国人的视角，但展开却颇具中国风，电影从祭奠祖先开始，清明节换成了墨西哥的亡灵节，想必这也是为什么评分如此之高的缘故之一，对于祭奠祖先，中国人都深有感触。\r\n小孩的曾曾祖父因为追逐音乐梦想抛弃了家庭，导致从那一辈开始，音乐就成了一个诅咒的词汇，整个家族以制鞋为业，若是主角小孩承袭家业继续制鞋的话，故事就没得讲了，小孩也和那个被诅咒的曾曾祖父一样爱上了音乐。“抓住机会，坚持梦想”这样的话语种下了反抗的种子。<strong>……</strong>"
  },
  {
    "fileName": "Webpack 4 升级.md",
    "ID": 43,
    "Title": "Webpack 4 升级",
    "Tags": "前端",
    "PublishDate": "2018/3/14 01:12:51",
    "Content": "\r\n因为依赖的关系，无法直接使用 npm up webpack 的方式更新，需要重新安装 webpack 4，除此之外还需要安装 webpack-cli ，然后一路跟着错误提示修改即可。\r\n1. >\r\n  The CLI moved into a separate package: webpack-cli.\r\n  Please install 'webpack-cli' in addition to webpack itself to use the CLI.\r\n  -> When using npm: npm install webpack-cli -D\r\n  -> When using yarn: yarn add webpack-cli -D\r\n\r\n照提示安装 weboack-cli 即可\r\n\r\n2. > Error: webpack.optimize.UglifyJsPlugin has been removed, please use config.optimization.minimize instead.\r\n\r\n这个插件在 webpack4 里已经不用手动引入了，直接 optimization.minimize 为 true 就行，生产模式下自动为 true。\r\n\r\n\r\n3. >\r\n  Error: webpack.optimize.CommonsChunkPlugin has been removed, please use config.optimization.splitChunks instead.\r\n\r\nCommonsChunkPlugin 已经再见，变为 optimization.splitChunks 和 optimization.runtimeChunk 两个配置，默认配置就会对异步请求的模块进行提取拆分，更多介绍看*[这里](https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366)*。\r\n\r\n4. >\r\nWebpack 4: compilation.mainTemplate.applyPluginsWaterfall is not a function\r\n\r\n解决办法 npm uninstall html-webpack-plugin 然后重装\r\n\r\n5. >\r\n  DeprecationWarning: Tapable.plugin is deprecated. Use new API on `.hooks` instead  77% module and chunk tree optimization unnamed compat plugin(node:14460) UnhandledPromiseRejectionWarning: \r\n\r\n依旧重装 extract-text-webpack-plugin 。\r\n\r\nwebpack 终于知道约定优于配置了，parcel 恐成最大输家。<strong>……</strong>"
  },
  {
    "fileName": "Web Worker 与 Service Worker.md",
    "ID": 44,
    "Title": "Web Worker 与 Service Worker",
    "Tags": "前端 | 编程",
    "PublishDate": "2017/12/16 21:09:35",
    "Content": "\r\n### Web Worker\r\n众所周知，浏览器的 JavaScript 是单线程的运行的，但随着 Web 应用的日趋复杂，越来越多的计算任务被分配给了前端，单线程运行的 JavaScript 早已不堪重负，因此就如何将 JavaScript 从单线程的地狱中解放出来就成问题了，因此诞生了 Web Worker， 它是脱离主线程之外的，因此一些复杂耗时的活可以交给它来干，但是有一点就是它不能操作 DOM，因此需要通过 postMessage 方法将执行结果告诉主线程，主线程通过 onMessage 方法获取返回结果。\r\n\r\n### Service Worker\r\n上面说到 Web Worker 解放了 JavaScript 的主线程，但有一个缺点就是 Web Worker 只是一个临时工而已，如果要长期存在且听候差遣呢？于是乎 Service Worker 应运而生，Service Worker 在 Web Worker 的基础上加上了持久离线缓存能力。\r\n\r\n#### 那么 Service Worker 到底用来干啥的呢？\r\nService Worker 有以下功能和特性：\r\n* 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。\r\n* 一旦被 install，就永远存在，除非被 uninstall\r\n* 需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）\r\n* 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）\r\n* 离线内容开发者可控\r\n* 能向客户端推送消息\r\n* 不能直接操作 DOM\r\n* 出于安全的考虑，必须在 HTTPS 环境下才能工作\r\n* 异步实现，内部大都是通过 Promise 实现\r\n\r\n简单来说，它可以代理你的前端所有请求，通过它再结合 caches API 你可以把所有的静态资源，甚至网络请求的数据缓存起来，然后由你自己编写的策略来决定是否去从后端取。我们知道原生 App 应用之所以能够获得很好的体验，一部分原因是因为它在断网的情况下依旧能使用部分功能，它的资源都是和 App 安装包打包到一起的，不需要频繁从后端去取。<strong>……</strong>"
  },
  {
    "fileName": "ukulele.md",
    "ID": 45,
    "Title": "ukulele",
    "Tags": "碎念",
    "PublishDate": "2017/7/22",
    "Content": "![](http://imglf.nosdn.127.net/img/UUcvQWZBZk9URHlpWHl5UmRMQkRPRU5aRHB5cVl6RnhNZWlaTnJLOXVjN1B0MUUxdTNXY0lnPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\r\n\r\n![](http://imglf.nosdn.127.net/img/UUcvQWZBZk9URHlpWHl5UmRMQkRPTUo3WjFUMWxYNUdNUG15MWw0QUZtdURYNnFoQXg3QVR3PT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\r\n\r\n一直想学个乐器来挑战下，在吉他和Ukulele之间犹豫了很久，直到看了jake shimabukuro的视频，卧槽？！这还能这么玩？于是便被种草了。  \r\n 当晚就在狗东下单买了kaka KUC-MAD，即便明知道可能是吃灰的命运，但依旧毫无犹豫。  \r\n 管他呢，再不济也能当做摄影道具，摆件，或者墙饰之类的。（我这样安慰自己=。=）\r\n\r\n    <strong>……</strong>"
  },
  {
    "fileName": "JS任督二脉-原型.md",
    "ID": 46,
    "Title": "JS任督二脉-原型",
    "Tags": "编码 | 前端",
    "PublishDate": "2015/12/24 23:43",
    "Content": "\r\nJavaScrpit中的类型有如下几种，除去一般类型以外其余都是对象。\r\n1. Number\r\n2. String\r\n3. Boolan\r\n4. Symbol (ES6新增)\r\n5. Object\r\n    * Function\r\n    * Array\r\n    * Date\r\n    * RegExp\r\n6. Null\r\n7. undefined\r\n\r\n**对象:** 对象在js中是一个键值对的集合，早期的js中并没有类Class，但类的概念却通过Object Prototype得以延续。\r\n在了解js中对象这个概念的基础上，再来看js的原型，相比涉及诸多底层实现概念的作用域而言，原型就容易懂得多，要弄懂原型，只涉及三个关键字: [[prototype]]、prototype、constructor\r\n\r\n一般情况下，我们这样来创建一个对象和函数：  \r\n```\r\n    var MyObject = {\r\n        name: 'myobject',\r\n    };\r\n\r\n    var MyFunction = function () {\r\n        name = 'myfunction';\r\n    };\r\n\r\n```\r\n\r\n当然，对象还可以通过new Class() 的方式来建立，在类似java的语言中中我们是通过构造方法\r\n来实例化一个对象的，在js中的new关键字也能\"实例化\"一个对象（实际上JavaScript不存在类，有的只是对象），而用来实例化的构造方法即是js的函数，对这样的方法我们称为**constructor**，但是对于js而言，**并不区分一般函数和构造函数**，只有在通过new 关键字来使用函数时才被当作是构造函数，用来“实例化一个对象”。\r\n使用构造函数实例化对象时这样写：\r\n```\r\n    var ClassA = function () {\r\n        this.className = 'A';\r\n    };\r\n    classa = new ClassA();\r\n```\r\n这样就得到了一个对象classa，看到new关键字，很多人都会觉得熟悉，但实际上这只是幻觉，它真真的机制并非如此。\r\n查看ClassA的属性，我们会发现一个ClassA.prototype对象，它有一个名为ClassA.prototype.constructor的属性，它是函数自身的引用，从字面上理解都以为是构造器，然后我们考虑下面代码：\r\n```\r\nfunction Foo() {      // ... }  \r\nFoo.prototype.constructor === Foo; // true  \r\nvar a = new Foo();  a.constructor === Foo; // true\r\n```\r\n我们猜测，当使用new Foo()创建对象a的时候，Foo.prototype.constructor作为构造函数创造了对象a，\r\n从 a.constructor === Foo可以看出。<strong>……</strong>"
  },
  {
    "fileName": "JS任督二脉-作用域.md",
    "ID": 47,
    "Title": "JS任督二脉-作用域",
    "Tags": "编码 | 前端",
    "PublishDate": "2015/12/8 22:40",
    "Content": "\r\n# 引言  \r\n多数人初次使用JavaScript的时候，恐怕都将其作为一种粘合剂使用，用诸如JQuery之类的库来控制页面为，与后端交互等。\r\n当然，这并没有错，这门语言在设计之初就是如此考虑的，但是随着Web技术的发展，JS却出乎意料的成为了浏览器语言的最终胜利者，并被各大浏览器支持，性能也得到了质的提升，隐隐有成为浏览器上的汇编语言这一趋势，出现了诸多以JS代码作为编译目标的语言，如CoffeeScript，TypeScript。\r\n\r\n随着Node.js等一系列的技术出现，JS的领域甚至被拓展至了浏览器之外，如React-Native开发ios、Android应用，GitHub开发的Atom编辑器，即便是在Web端，随着各种前端框架、工程化工具的不断涌现，JS也越来越受到重视，现在JavaScript已经成为了世界上使用最广泛的软件平台，互联网的核心技术。\r\n\r\n**是时候严肃认真的学习它了，深入才能察觉深度，当你学习诸如闭包，this，作用域链，原型链等概念的时候，你会发现JS并不简单！**\r\n\r\n# 作用域与原型\r\n## 作用域\r\n为什么称其为JS的任督二脉？与之相关的概念有作用域链、原型链，而JS中那些最复杂的概念，如闭包等概念其实都在建立在这两套机制之上的，可以说理解了JS的作用域与原型，就掌握了JS精髓的70%!，也只有理解了这两个概念，才能从容自信的使用JS中的各种魔法，或是处理各种奇怪的问题。\r\n作用域一词从字面上来理解，即代码中标识符被限定的可见范围，某些标识符并不总是可见的，会因为声明位置的不同而有所差异。<strong>……</strong>"
  },
  {
    "fileName": "Cycle.js 体验.md",
    "ID": 48,
    "Title": "Cycle.js 体验",
    "Tags": "前端",
    "PublishDate": "2018/3/25 20:38:26",
    "Content": "\r\n之前学习了流的概念，那么理所当然的会想到其应用，特别是在前端领域大规模应用函数式编程范式的情况下，果不其然，我发现了Cycle.js 这个框架，相比于 React ，Cycle.js 可谓是更加彻底的函数式了。\r\n```\r\nfunction main(sources) {\r\n  const sinks = {\r\n    DOM: sources.DOM.select('input').events('click')\r\n      .map(ev => ev.target.checked)\r\n      .startWith(false)\r\n      .map(toggled =>\r\n        <div>\r\n          <input type=\"checkbox\" /> Toggle me\r\n          <p>{toggled ? 'ON' : 'off'}</p>\r\n        </div>\r\n      )\r\n  };\r\n  return sinks;\r\n}\r\nconst drivers = {\r\n  DOM: makeDOMDriver('#app')\r\n};\r\nrun(main, drivers);\r\n```\r\n\r\n<img src=\"http://cyclejs.cn/img/hci-inputs-outputs.svg\" alt=\"HCI 输入 输出\" width=\"500px\">  \r\n\r\n\r\n\r\n整个框架的核心是一个不到两百行代码的 run 函数。让我们思考这样一种人机交互模型，计算机接受用户的操作作为输入，并输出一个新的视图，人的眼睛作为感知器将计算机输出的视图作为输入，输出一个操作。\r\n\r\n```javascript\r\ncomputer(Input) => Output\r\nHuman(senses) => Actuator\r\n```\r\n在这个模型里，人与计算机互为观察者，二者都可以抽象为一个函数，而 run 的作用就是将这两个函数连接起来，这也就是 cycle.js 的由来。\r\n\r\nrun 的第二个参数实际上是一个 driver，用来执行 JS 代码的副作用，即那些影响外部世界到操作，比如将 Virtual DOM 渲染到真实屏幕，捕捉各种事件等。<strong>……</strong>"
  },
  {
    "fileName": "CSS3动画学习.md",
    "ID": 49,
    "Title": "CSS3动画学习",
    "Tags": "编码",
    "PublishDate": "2017/11/12 15:29:49",
    "Content": "\r\n## 属性\r\nCSS3 中涉及动画的三个属性为 transitions, transforms, animation。\r\n\r\ntransition： 一般用于过渡动画处理\r\ntransform： 用于变换，旋转、拉伸、收缩等\r\nanimation： 用于动画\r\n\r\n### transition\r\ntransition-property：指定应用过渡属性的名称\r\ntransition-duration：指定过渡的持续时间\r\ntransition-delay：延迟过渡时间\r\ntransition-timing-function: 指定过渡类型\r\n\r\n    <strong>……</strong>"
  },
  {
    "fileName": "coding.md",
    "ID": 50,
    "Title": "coding",
    "Tags": "碎念",
    "PublishDate": "2017/7/20 01:35:08",
    "Content": "\r\n![](http://imglf0.nosdn.127.net/img/UUcvQWZBZk9URHhUNmthQzQxSXpDZnFmRWN3aTQ5MGozdXh2NUF6RlZFM0hWRUluM3dWaFZnPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg)\r\n在公司忙活项目的Coding，回到家中亦是摆弄自己的代码，对我而言却是极其幸运的，因为爱好即是工作。  \r\n张嘴就唠叨个不停，没人聊就撩计算姬好了😂\r\n    <strong>……</strong>"
  }
]