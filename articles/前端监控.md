---
Title: 前端监控
Tags: 前端
PublishDate: 2018/7/10 18:09:14
---

## 背景

最近项目痛点，就是应用在我们的设备上好好的，怎么一到用户那就反馈各种问题呢？这个痛点相信不止我一个人遇到，甩给测试去控制那也不容易啊，如果公司穷，测试设备覆盖不全就更痛苦了，而且用户对问题无法给出技术性的描述，作为开发只能靠经验推断，心累。

于是最近几天我就研究了下**前端监控**相关的内容，写了个简单的信息采集工具，当然，业界已经有许多现成的方案了，如 funDebug、bugsnag、BadJS、betterjs 等，但我就是想自己造一个轮子！

好像代码量不多？我上我也行（错觉），自己造一个学习下（最重要的理由）。

GitHub 链接：[fe-monitor](https://github.com/lzcers/femonitor/tree/master/src)

## 设计要求

- 易于扩展，可自定义

  我哪天想到啥新的监控点可以直接扩展，比如说不仅仅是性能监控，js 错误监控之类的，订单请求也可纳入监控范围啊，不是偶尔掉单吗？前端也可以抓点数据嘛。还有用户行为路径之类的数据。

- 无侵入，小侵入

  最好简单引入个 sdk 就行，尽可能不要埋点

- 适用不同框架

  比如连接 Vue.config.errorHandle 

## 模块

- 信息采集
- 信息上报 
- 信息分析
- 报警
- 信息可视化

在前端主要做的就是信息采集和信息上报，数据到了后端存储后再做信息分析，报警，可视化之类的工作，那么问题来了，首先要确定是到底要**采集哪些数据**？采用什么**上报策略**？所有数据一律上报显然不现实，没那必要，也没那么大存储空间。

## 信息采集

首先，我们采集信息的目的是什么？在这里我希望能够**主动发现问题**，**了解我们的应用在客户那的运行情况**，大部分问题产生的原因主要是这些

* 资源文件加载出错
* 接口访问错误
* 服务器错误
* 前端代码错误
* 兼容性问题（css或是js）
* 用户操作出错

更进一步我们可以监控用户的行为路径，运营数据等，优化并提高转化率。

最后根据我们的需求整理来看，主要监控的就是这几类：

**网络请求监控**

* web 资源的加载速度 （performance.getEntriesByType('resource')）
* HTTP 资源加载异常 （addEventListener(error)）
* 异步请求 API 调用的成功率以及响应延时（劫持掉原生的 XHR 和 fetch）

**页面渲染 / 交互监控**

* JS 运行异常 （onerror等）
* 页面性能 （performance.timing）

**用户环境信息**
* IP (需要借助第三方服务，或者自己实现后端接口)
* 浏览器 （UA 不准）
* 操作系统（UA 不准，navigator.platform）
* 语言 （navigator.language）

### 页面性能监控

为啥要做性能监控呢？因为性能与利益直接相关。

> 有数据调查显示：当Google 延迟 400ms时，搜索量下降 0.59%、Bing 延迟 2s，收入下降 4.3%、Yahoo 延迟 400ms，流量下降 5-9%，所以，很多公司在做用户体验分析时，第一个看的就是性能监控指标。

对前端而言，重要的性能指标有这些：

1. 白屏时间：（first Paint Time）用户打开页面到看到东西的时间
2. 首屏时间：用户首屏内容全部加载出来花费的时间
3. 用户可交互时间：从看到东西到可操作的时间
4. 总下载时间：页面所有资源都加载完成并呈现出来所花的时间
5. DNS 查询时间
6. TCP 连接建立时间
7. HTTP 请求响应时间

幸运的是，*几乎*所有这些性能指标，在 IE9 以上都可以通过一个接口拿到 `performance.timing`。

![gtmetrix](http://fex.baidu.com/img/build-performance-monitor-in-7-days/timing.png)  

根据上图所示我们可以这样计算这些性能指标

```javascript
const perf = window.performance
const timing = perf.timing
const perfInfo = {
    dns: timing.domainLookupEnd - timing.domainLookupStart, // DNS查询耗时，太长可以考虑 DNS 预解析 
    connect: timing.connectEnd - timing.connectStart, // TCP 链接耗时，服务器网络环境太水了吧？
    whtite: timing.responseStart - timing.navigationStart, // 白屏时间
    domp: timing.domComplete - timing.domInteractive, // 解析 DOM 的时间，是不是嵌套太深了？
    dom: timing.domContentLoadedEventEnd - timing.navigationStart, // dom 渲染完成时间， 可以视作用户可操作时间
    request: timing.responseEnd - timing.responseStart, // request 请求耗时
    onload: timing.loadEventEnd - timing.navigationStart // 总下载时间, 页面 onload 时间
}
```

对于首屏时间我还没找到好的方案，现在前端开发都是用各种框架来做的，不好计算呀。



### JS 运行监控

在 JS 里错误（Error）和异常（Exception）被视作一类，但是对两个概念的区分是有意义的，所谓的异常就是需要被程序员处理的情况，这意味着异常是可以被预见且控制的，它是由程序员导致的错误，应该在应用程序中处理，也就是被`try catch`包裹着。对于异常，如果做了妥善的处理则并不会导致程序崩溃。

而处理方式通常就是降级，或者隔离，如果说一处代码发生了异常，而后续的操作又依赖其执行结果，我们可以则可以**隔离**处理，如果不依赖，那就可以考虑**降级**，对这次操作的结果指定一个值。对于常见的网络错误最简单的处理策略就是**重试**，但是重试又要考虑时间间隔，是线性的间隔重试呢，还是时间指数增长的重试。

再说错误，与异常刚好相反，它是不可控的，会让程序崩溃，对于 JS 而言，我们遇到的情况通常是异常，虽然错误报告中往往带有 Error 字样，JS 里的错误只会让当前程序终止，而不会让 JavaScript 引擎崩溃，在发生错误时，JS 引擎会跳过当前执行的 JS 文件，去执行其它的。

关于 JavaScript 错误可以参考 MDN 文档 [JavaScript 错误参考](https://saijs.github.io/wiki/wiki/index)，以及 saijs 整理的档案 [JavaScript 异常档案](https://saijs.github.io/wiki/wiki/index)。

这里我们只关注并收集几类错误：

* JS 运行时错误（包括语法错误）
* 资源加载错误
* 接口请求错误

#### JS 运行时错误

对于 JS 运行时错误，最简单的办法也就是绑定`window.onerror`事件处理函数，但在这之前要保存原有的 onError 处理函数，执行后再调用原有的 onerror 处理函数，为了捕捉到所有的错误，监控程序应该在所有 JS 脚本之前执行。

```javascript
// 备份原有的 errorHandler
const errHandler = window.onerror
window.onerror = function(message, source, lineno, colno, error) {
    ...
    // 报告错误
    $.emit({
        type: 'jsErr',
        date: Date.now(),
        source,
        content: { ...errInfo, msg }
    })
    // 再调用原有的 onerror 处理
    errHandler && errHandler.apply(this, arguments)
}
```

通过`error.stack`可以拿到错误的堆栈信息，在没有堆栈信息的情况，我们也可以通过递归调用`arguments.callee.caller`来获取，但该属性在严格模式下不可用，而且即将被废弃。

```javascript
if (!!arguments.callee) {
    //尝试通过callee拿堆栈信息
    let f = arguments.callee.caller,
        c = 3
    while (f && --c > 0) {
        msg += f.toString() + ','
        if (f === f.caller) break
        f = f.caller
    }
}
```

`window.onerror`并非万能，对于来自**不同域**的语法错误，为了避免信息的泄露，语法错误的细节不会报告，而代之以简单的`"Script error."`，在较为新的浏览器中可以为`<script>` 添加`crossorigin`属性，并要求服务器发送适当的 [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS) HTTP 响应头来绕过这个限制。当然，也有很多其它的方案， 比如通过  babel，Webpack 插件等工具对所有非同源函数入口自动包裹 `try catch`，或者手动写代码劫持已知的异步加载器入口函数添加 `try catch`。

`try catch`会影响编译器代码优化，影响性能，但据说在新版的 V8 浏览器中已经解决该问题。



还有一个要考虑的也就是 Promise 中 reject 未处理的异常，对此我们可以监听`unhandledrejection`事件来处理。

````javascript
window.addEventListener('unhandledrejection', function(err){}
````

#### 资源加载错误

对于资源加载报错，该事件不会冒泡到 window，因而需要监听 `error` 事件，并在捕获阶段处理，通过`err.target == window `识别是否是资源加载类错误。

```javascript
window.addEventListener('error',function(err) {
    // 资源加载类错误的 target 不是 window
    if (err.target == window) return
}, true)
```

#### 接口请求错误

对于接口请求，其底层多是通过创建 `XMLHttpRequest `对象来实现，少数也有使用`fetch`，实现对请求的监控，比如超时，报错等，可以通过代理原生 `XMLHttpRequest`，`fetch`对象来实现。

```javascript
const _realXML = XMLHttpRequest 
const _fetch = window.fetch 
XMLHttpRequest = function() {
    this.xhr = new _realXML()
    this.xhr.onreadystatechange = hookXHR
    // 拷贝 XMLHttpRequest 的所有属性
    // 不能用扩展运算符拷贝，因为不会遍历到继承的属性
    for (let attr in this.xhr) {
        // 不考虑兼容性，也可以使用新的 proxy 对象
        Object.defineProperty(this, attr, {
            set: hookSet(attr),
            get: hookGet(attr)
        })
	}
    ...
}
```

`hookGet` 主要是对`open`方法进行拦截，以此来记录 Method、URL

```javascript
if (attr == 'open') {
    return function(...args) {
        ajaxMethod = args[0]
        ajaxUrl = args[1]
        return this.xhr.open.apply(this.xhr, args)
    }
}
```

劫持 `onreadystatechange `的 setter，添加默认的处理函数，根据`readyState `判断请求状态来决定是否上报。

```javascript
function hookXHR() {
    switch (this.readyState) {
            // open() 方法已经调用
        case 1:
            ajaxStartTime = Date.now()
            break
            // 请求完成
            case 4:
            ajaxEndTime = Date.now()
            ajaxStatus = this.status
            // 超时上报
            timeoutReport()
            if (this.status >= 400) {
                ajaxStatusText = this.responseText
                errorReport()
            }
            break
    }
}
```

fetch 也是类似的处理方式

```javascript
window.fetch = function(...args) {
    ajaxUrl = args[0]
    const options = args[1]
    if (typeof options == 'object') ajaxMethod = options['method']
    else ajaxMethod = 'GET'
    ajaxStartTime = Date.now()
    return _fetch
        .apply(this, args)
        .then(res => {
            ajaxEndTime = Date.now()
            ajaxStatus = res.status
            if (res.status >= 400) errorReport()
        	return res
    	})
        .catch(err => {
            ajaxStatusText = 'fetch error:' + err
            errorReport()
            return err
    	})
}
```

### 上报的策略

最后说说上报的策略，错误往往是连带发生的，因而对于每个错误都发送请求至后端是开销比较大的，所以可以考虑对信息进行`合并上报`，所有错误都一律收集也是不可取的，比如某些相同的错误只要上报一次即可，我们的存储也是有限的，不需要对所有错误都收集，因而只需要``抽样上报``，为了避免上报堵塞主线程，我们可采`取延迟上报`的策略。

通常上报都是通过`new Image() `来发送请求，因为这样可以不受跨域限制，但是 GET 请求的长度有限制，因而我们要对收集的到信息分片，分成多组分开来上报。



### 用户环境信息

我们简单点从 navigator 取 userAgent、platform、lang 即可，尽管这并不可靠，但够用，更细致一点可以做浏览器指纹判断，这个当然找第三方库咯，还有 IP 也可以通过第三方接口服务获取，也可以让监控的后端自己存。

```javascript
userAgent: navigator.userAgent || '',
platform: navigator.platform || '',
lang: navigator.language || '',
```



----

一些参考的文档：

http://www.alloyteam.com/2015/09/explore-performance/ 使用 window.performance 提供了一组精确的数据，经过简单的计算就能得出一些网页性能数据。

https://www.cnblogs.com/fsjohnhuang/p/7685144.html  前端魔法堂——异常不仅仅是try/catch

http://www.alloyteam.com/2014/03/front-end-data-monitoring/ 前端相关数据监控

http://rapheal.sinaapp.com/2014/11/06/javascript-error-monitor/ 前端代码异常监控

https://zhuanlan.zhihu.com/p/31979395 前端代码异常监控实战

https://github.com/fengyaogit123/monitor-js 轻量级前端错误监控插件

https://saijs.github.io/wiki/ JavaScript 异常档案

https://github.com/suguangwen/neky-err 前端异常捕捉

https://zhuanlan.zhihu.com/p/32262716 把前端监控做到极致

https://zhuanlan.zhihu.com/p/23310438 不可忽视的前端监控

https://blog.seosiwei.com/detail/30 performance-report页面性能、资源、错误、ajax，fetch请求上报插件

 https://zhuanlan.zhihu.com/p/35442263  前端性能监控系统开发

http://fex.baidu.com/blog/2014/05/build-performance-monitor-in-7-days/ 7 天打造前端性能监控系统

 https://zhuanlan.zhihu.com/p/35614506 Performance — 带你监控前端性能

https://zhuanlan.zhihu.com/p/33712608 开发完第一版前端性能监控系统后的总结

https://zhuanlan.zhihu.com/p/27305665 前端异常监控平台的设计思路及实现

https://zhuanlan.zhihu.com/p/32761159 2017前端监控系统探索总结

https://zhuanlan.zhihu.com/p/37298838 前端错误监控与收集探究

https://zhuanlan.zhihu.com/p/26085642 前端异常监控系统的落地
